# Варианты 13579

## 1. Чем `@ViewScoped` бины отличаются от `@CustomScoped`?

### @ViewScoped - экземпляр создаётся один раз при обращении к странице, и используется ровно столько, сколько пользователь находится на странице:

1. **Жизненный Цикл**: Существует в течение одного представления (view) JSF.
2. **Использование**: Часто используется для AJAX-взаимодействий в рамках одной страницы.
3. **Особенности**: Уничтожается при переходе на новую страницу.

### @CustomScoped - экземпляр создаётся и сохраняется в Map. Программист сам управляет областью жизни:

1. **Жизненный Цикл**: Пользовательский; определяется через `Map объект`.
2. **Использование**: Для специфических требований, не покрываемых стандартными скоупами.
3. **Особенности**: Гибкость в определении жизненного цикла.

`@ViewScoped` подходит для стандартных сценариев на одной странице, тогда как `@CustomScoped` предлагает больше гибкости для специализированных случаев.

## 2. Чем конструкция ${bean.property} отличается от конструкции #{bean.property}?

В Expression Language (EL) существуют два типа выражений: `${}` (Immediate) и `#{}` (Deferred).

1. **`${bean.property}` (Immediate)**
   - **Жизненный Цикл**: Вычисляется немедленно на этапе обработки страницы (срабатывают, как только разворачивается представление в 1ой фазе ЖЦ).
   - **Ограничения**: Только чтения, а не для записи данных, не может быть использовано для привязки к компонентам, требующим двустороннего взаимодействия.
   
2. **`#{bean.property}` (Deferred)**
   - **Жизненный Цикл**: Вычисляются в определенный момент жизненного цикла JSF, который может быть управляем. Это может происходить, например, при событиях валидации, обновления модели и так далее.
   - **Особенности**: Поддерживает как чтение, так и запись. Используется для привязки компонентов к бинам.

`${}` используется для односторонних операций, в основном чтения, тогда как `#{}` используется для двустороннего взаимодействия и поддерживает больше функциональности.

## 3. Код managed bean, содержащего метод, возвращающий время с момента рестарта сервера или деплоя приложения

```java
import javax.annotation.PostConstruct;
import javax.faces.bean.ManagedBean;
import javax.faces.bean.ApplicationScoped;
import java.time.Duration;
import java.time.LocalDateTime;

@ManagedBean
@ApplicationScoped
public class TimeSinceRestartBean {

    private LocalDateTime startTime;

    @PostConstruct
    public void init() {
        startTime = LocalDateTime.now();
    }

    public String getTimeSinceRestart() {
        Duration duration = Duration.between(startTime, LocalDateTime.now());
        long seconds = duration.getSeconds();
        long hours = seconds / 3600;
        long minutes = (seconds % 3600) / 60;
        seconds = seconds % 60;

        return String.format("%d hours, %d minutes, %d seconds", hours, minutes, seconds);
    }
}
```
<hr>

# Варианты 24680

## 1. В чем разница между @NoneScoped бинами и @ApplicationScoped?

`@ApplicationScoped` - экземпляр managed bean создаётся один раз при обращении и используется на протяжении жизни всего приложения. Не должен иметь состояния, а если имеет, то должен синхронизировать доступ, так как доступен для всех пользователей. Контекст — приложение.
`@NoneScoped` - экземпляр managed bean создаётся, но не привязывается ни к одной области жизни. Жизненным циклом управляют другие managed beans. Бин без контекста.

## 2. Какой из этих фрагментов кода не скомпилируется и почему? (1) #{bean.action} (2) #{bean.action()}

Оба фрагмента кода являются синтаксически корректными выражениями Expression Language (EL) и могут быть использованы в страницах JSF. Однако их поведение будет разным:

1. `#{bean.action}`: Это выражение будет пытаться получить значение свойства или метода `action` в бине. Если такого свойства или метода нет, будет выброшено исключение во время выполнения, но не во время компиляции.
   
2. `#{bean.action()}`: Это выражение будет пытаться вызвать метод `action()` в бине. Если такого метода нет, будет выброшено исключение во время выполнения.

Оба эти фрагмента не вызывают ошибок компиляции, потому что они обрабатываются во время выполнения, и JSF/EL отложенно проверяют наличие соответствующих методов или свойств.


## 3. Код для JSF страницы, показывающей значение параметра user-name из HTTP запроса
```java
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:h="http://java.sun.com/jsf/html">
<head>
    <title>Show User Name</title>
</head>
<body>

    <h:outputText value="User Name from HTTP Request: #{param['user-name']}" />

</body>
</html>
```
