## Билет 1

### 1. CDI бины, именование CDI бинов, @Alternative

**CDI Beans**
- Универсальные компоненты уровня бизнес-логики.
- Абстрактная реализация паттерна CDI в Java / Jakarta EE.
- «Клонируют» основные концепции бинов из Spring.
- Общая идея – «отвязаться» от конкретного фреймворка при создании бизнес-логики внутри приложения.
- Конфигурируются аннотациями, основной пакет – javax.enterprise.context.
- Для CDI используется универсальная аннотация @Inject.
- В отличие от EJB, не обеспечивают горизонтальную масштабируемость «сами по себе»
- Разные контексты (мб перчислить)

**Именование бинов**

1. Неявное Именование: По умолчанию, CDI автоматически присваивает имя бину, основываясь на имени класса с первой буквой в нижнем регистре. Например, класс PaymentService будет иметь имя бина paymentService.
2. Явное Именование с @Named: Если вам нужно использовать конкретное имя для бина, можно использовать аннотацию @Named, чтобы указать это имя. Это полезно для доступа к бинам в EL-выражениях (Expression Language) в JSF и других технологиях.


**@Alternative**

Аннотация @Alternative позволяет определить дополнительные реализации для бина, которые могут быть выбраны вместо стандартной реализации. Для активации альтернативного бина его нужно указать в файле конфигурации beans.xml. Это особенно полезно в ситуациях, когда есть несколько реализаций одного и того же интерфейса, и надо явно выбрать, какая реализация должна использоваться в определенном контексте приложения.

### 2. DI в Angular
**Dependency injection**
- Общая концепция: зависимости объекта передаются ему извне, а не создаются самим объектом
- Компоненты могут использовать сервисы с помощью DI.
- Для того, чтобы класс можно было использовать с помощью DI, он должен
содержать декоратор @Injectable()

**Основные принципы реализации DI**
- Приложение содержит как минимум один глобальный Injector, который
занимается DI.
- Injector создаёт зависимости и передаёт их экземпляры контейнеру
- Провайдер (provider) -- это объект, который сообщает Injector’у, как
получить или создать экземпляр зависимости.
- Обычно провайдером сервиса является сам его класс. Для каждого сервиса должен быть зарегистрирован как минимум один провайдер.
- Зависимости компонентов указываются в качестве параметров их конструкторов

### 3. Конфигурация Spring Web MVC без использования Spring Boot. Написать web.xml для приложения развернутого на сервере приложений Jakarta EE

## Билет 2

### 1. Location Transparency. Реализация в Java/Java EE

Location Transparency описывает концепцию, согласно которой клиентский код может вызывать методы на объекте (или сервисе) без знания физического местоположения этого объекта. Благодаря CDI не важно, где физически
расположен вызываемый компонент — за его
вызов отвечает контейнер.

В Java и Java EE, Location Transparency традиционно достигается с использованием нескольких технологий:

1. **RMI (Remote Method Invocation)**: Это базовая технология Java для взаимодействия между приложениями в сети. RMI позволяет объектам, расположенным на разных JVM, взаимодействовать друг с другом так, как будто они находятся в одной JVM.

2. **EJB (Enterprise JavaBeans)**: В рамках Java EE, EJB обеспечивает более высокоуровневый способ достижения прозрачности расположения. Stateful, Stateless и Singleton session beans могут быть доступны для клиентских приложений без информации о их физическом расположении.

3. **JNDI (Java Naming and Directory Interface)**: Используется для поиска EJB и других ресурсов в сети. Клиенты ищут сервисы по логическому имени, и JNDI обеспечивает связь с физическим расположением или конкретной реализацией сервиса.

4. **Web Services (SOAP and REST)**: Они обеспечивают еще один уровень прозрачности расположения, позволяя клиентам обращаться к сервисам через HTTP, не заботясь о деталях их реализации.

### 2. Реализация уровня представления в Spring Web MVC


### 3. Напишите реакт компонент реализующий карусель изображений поле каруселью подразумевается , отображается одно изображение из н, можно переключать кнопками вперёд и назад пролистывая изображения, хранятся на клиентском устройстве, список путей к файлам передавать через props

## Билет 3

### 1. RMI. Реализация RMI в Java EE



## Билет 4

### 1. Управляемые бины - назначение, способы конфигурации, доступ из jsp/xhtml

**Назначение**
- Содержат параметры и методы для обработки данных с компонентов.
- Используются для обработки событий UI и валидации
данных.
- Жизненным циклом управляет JSF Runtime
Envronment.
- Есть разные контексты (Request, Session, Application...)
- Доступ из JSF-страниц осуществляется с помощью
элементов EL.
- Конфигурация задаётся в faces-config.xml (JSF 1.X),
либо с помощью аннотаций (JSF 2.0).
- Вместо них могут использоваться CDI-бины, EJB или
бины Spring.

**Конфигурация**

1. Способ 1 — через faces-config.xml:

```xml
<managed-bean>
<managed-bean-name>customer</managed-bean-name>
<managed-bean-class>CustomerBean</managed-bean-class>
<managed-bean-scope>request</managed-bean-scope>
<managed-property>
<property-name>areaCode</property-name>
<value>#{initParam.defaultAreaCode}</value>
</managed-property>
</managed-bean>
```

2. Способ 2 (JSF 2.0) — с помощью аннотаций:

```java
@ManagedBean(name="customer")
@RequestScoped
public class CustomerBean {
...
@ManagedProperty(value="#{initParam.defaultAreaCode}"
name="areaCode")
private String areaCode;
...
}
```

**Использование**

Доступ к управляемым бинам со страниц приложения осуществляется с помощью EL-выражений:

```xhtml
...
<h:inputText value="#{user.name}"
validator="#{user.validate}" />
...
<h:inputText binding="#{user.nameField}" />
...
<h:commandButton action="#{user.save}"
value="Save" />
...
```

### 2. Архитектура и состав Spring Web MVC
Spring Web MVC – “базовый” фреймворк в составе Spring для разработки веб-приложений, основан на паттерне MVC; универсальный, удобен для
разработки REST API.

**Архитекутра**

![image](https://github.com/eliteSufferer/ITMO_Studies/assets/46615564/84e164fc-ca6d-4a07-bf9c-aa26a77a5c5e)

1. **HTTP Request**: Все начинается с HTTP-запроса, который отправляется на сервер.

2. **DispatcherServlet**:
   - Обрабатывает все запросы и формирует ответы на них.
   - Связывает между собой все элементы архитектуры Spring MVC.
   - Обычный сервлет – конфигурируется в web.xml.

3. **Handler Mapping (1)**:
   - Интерфейс, позволяющий распределять запросы по различным обработчикам (контроллерам).
   - Помимо «основного» Handler'а, в обработке
запроса могут участвовать один или несколько
«перехватчиков» (реализаций интерфейса HandlerInterceptor).
  - Механизм в общем похож на сервлеты и
фильтры.

4. **Controller (2)**:
   - Контроллер берет на себя обработку запроса после того, как `Handler Mapping` определяет, что он должен этим заниматься.
   - Здесь выполняется бизнес-логика, обработка данных из запроса, взаимодействие с Model (сервисы, компоненты доступа к данным и т.д.) и возвращается некоторый результат, обычно в виде имени представления и модели данных для этого представления (объект `ModelAndView`).

5. **View Resolver (3)**:
   - Представление в Spring Web MVC может быть построено
на разных технологиях, с каждым представлением сопоставляется его
символическое имя.
   - Преобразованием символических имён в ссылки на
конкретные представления занимается специальный
класс, реализующий интерфейс
org.springframework.web.servlet.ViewResolver.
   - В одном приложении можно использовать несколько
ViewResolver'ов.
   - После того, как контроллер выполнит свою работу, `View Resolver` определяет, какое представление должно быть использовано для отображения результатов выполнения.
   - Он преобразует логическое имя представления, предоставленное контроллером, в фактический путь к файлу представления (например, к файлу JSP).

1. **View (4)**:
   - Представление отвечает за отображение ответа пользователю. Это может быть страница JSP, HTML и т.д., которая рендерит данные, предоставленные контроллером.
   - После рендеринга представление (View) возвращается обратно в `DispatcherServlet`.

2. **HTTP Response**:
   - Наконец, `DispatcherServlet` отправляет сформированный ответ обратно клиенту.

Эта схема демонстрирует, как Spring MVC следует паттерну "Front Controller", где `DispatcherServlet` играет центральную роль в координации процесса обработки запроса, взаимодействия с компонентами бизнес-логики и подготовке ответа для клиента.
**Состав приложения**

- Model:
  - Хранит данные, необходимые для
    формирования представления.
  - Сами по себе эти данные – обычные POJO.
  - В общем случае, реализует интерфейс
    org.springframework.ui.Model.
  - Есть «упрощённая» реализация,
    представляющая из себя Map - org.springframework.ui.ModelMap.
- View – отвечает за отображение данных модели.
  - Фреймворк не специфицирует жёстко
  технологию, на которой должно быть построено
  представление.
  - Вариант «по-умолчанию» – JSP.
  - Можно использовать Thymeleaf, FreeMarker, etc.
  - Можно реализовать представление вне
  контекста Spring – целиком на JS.
- Controller – обрабатывает запрос пользователя,
создаёт соответствующую модель и передаёт её
для отображения в представление.
  - Класс, который связывает модель с
представлением, управляет состоянием модели.
  - Помечается аннотацией @Controller.
  - Класс или его методы могут быть помечены
  аннотациями, «привязывающими» их к
  определённым методам HTTP или URL.

### 3. Интерфейс на angular, проверяющий, аутентифицирован ли пользователь(по наличию куки jsessionid), и, если нет, позволяющий ему аутентифицировться посредством ввода логина и пароля.

```ts
import { Component } from '@angular/core';
import { CookieService } from 'ngx-cookie-service';

@Component({
  selector: 'app-auth',
  template: `
    <div *ngIf="!isAuthenticated">
      <form (ngSubmit)="login()">
        <input type="text" [(ngModel)]="username" name="username" placeholder="Username">
        <input type="password" [(ngModel)]="password" name="password" placeholder="Password">
        <button type="submit">Login</button>
      </form>
    </div>
    <div *ngIf="isAuthenticated">
      <p>User is authenticated</p>
      <!-- Другие элементы пользовательского интерфейса для аутентифицированного пользователя -->
    </div>
  `
})
export class AuthComponent {
  isAuthenticated = false;
  username: string;
  password: string;

  constructor(private cookieService: CookieService) {}

  ngOnInit() {
    this.isAuthenticated = this.cookieService.check('JSESSIONID');
  }

  login() {
    // Здесь должна быть логика аутентификации
    // Например, отправка данных на сервер и установка куки JSESSIONID при успешном входе
  }
}
```

## Билет 5

### 1. Области видимости MB. Способы задания области видимости

**Сопособы конфигурации**: Задаётся через faces-config.xml или с помощью аннотаций.


Пример через faces-config:
```xml
<managed-bean>
<managed-bean-name>customer</managed-bean-name>
<managed-bean-class>CustomerBean</managed-bean-class>
<managed-bean-scope>request</managed-bean-scope>
...
```

Через аннотации:
```java
@ManagedBean(name="customer")
@RequestScoped
public class CustomerBean {
...
}
```

6 вариантов конфигурации:
- @NoneScoped — контекст не определён, жизненным
циклом управляют другие бины.
- @RequestScoped (применяется по умолчанию) — Бин создается заново при каждом HTTP запросе, используется для коротких операций, не требующих сохранения состояния между запросами.
- @ViewScoped (JSF 2.0) — Бин остается активным в течение жизни одного и того же JSF view (например, пока пользователь находится на одной и той же странице). Используется для операций, состояние которых должно сохраняться при AJAX-запросах на одной странице.
- @SessionScoped — Бин остается активным в течение всей пользовательской сессии. Используется для данных, которые должны сохраняться между различными запросами в рамках одной сессии пользователя.
- @ApplicationScoped — Бин остается активным в течение всего времени жизни приложения. Используется для данных, общих для всех пользователей приложения.
- @CustomScoped (JSF 2.0) — бин сохраняется в Map; программист сам управляет его жизненным циклом.

### 2. Принципиальные различия spring и java EE

Spring Framework и Java/Jakarta EE представляют собой две популярные платформы для разработки предприятия в экосистеме Java. Обе платформы обеспечивают обширный набор функций для создания масштабируемых и гибких приложений, но имеют ряд принципиальных отличий в подходах к реализации и архитектуре.

### Идейные отличия:
- «Базовая» концепция Java EE – разделение
обязанностей между контейнером и
компонентом; «базовая» концепция Spring – IoC /
CDI.
- Контейнер в Java EE включает в себя
приложение; приложение в Spring включает в
себя контейнер.
- Java EE – спецификация; Spring – фреймворк.

### 1. Подход к Конфигурации

- **Spring**: Использует подход "конфигурация через код" (JavaConfig), позволяя разработчикам определять бины и конфигурации непосредственно в Java-коде. Поддерживает также декларативную конфигурацию через XML и аннотации. Spring Boot дополнительно предоставляет автоматическую конфигурацию на основе классов, доступных в classpath.
- **Java/Jakarta EE**: Традиционно использовал декларативный подход с помощью XML-файлов, но современные версии Jakarta EE также широко используют аннотации и CDI (Contexts and Dependency Injection) для упрощения конфигурации.

### 2. Внедрение Зависимостей (Dependency Injection)

- **Spring**: Одна из ключевых особенностей Spring - это мощная поддержка внедрения зависимостей через аннотации (`@Autowired`) и конструкторы. Spring Boot упрощает этот процесс еще больше.
- **Java/Jakarta EE**: CDI является стандартом для внедрения зависимостей в Java EE. Он также использует аннотации (например, `@Inject`) и обеспечивает тесную интеграцию с другими компонентами Java EE.

### 3. Стандарты и Портативность

- **Spring**: Хотя Spring использует некоторые стандарты Java EE, такие как JPA для работы с базами данных, он сам по себе не является стандартом и работает как самостоятельный фреймворк.
- **Java/Jakarta EE**: Полностью основан на стандартах, что обеспечивает высокий уровень портативности между различными реализациями и серверами приложений.

### 4. Модель Программирования

- **Spring**: Предоставляет более гибкую и легкую модель программирования, что делает его популярным выбором для создания микросервисов и облачных приложений.
- **Java/Jakarta EE**: Следует более формальному подходу, основанному на стандартах, что может быть предпочтительнее в больших и строго стандартизированных корпоративных средах.


## Билет 6

### 1. Фазы Invoke Application и Render Response

Эти две фазы идут после фазы обновления значений компонентов.

**Invoke Application:**

На этом этапе реализация JavaServer Faces обрабатывает все события на уровне приложения, такие как отправка формы или переход на другую страницу.

**Render Response:**
- JSF Runtime обновляет представление в соответствии с результатами обработки запроса.
- Если это первый запрос к странице, то компоненты помещаются в иерархию представления.
- Формируется ответ сервера на запрос.
- На стороне клиента происходит обновление страницы.

### 2. Какие задачи выполняет Spring Boot

Spring Boot — это часть большой экосистемы Spring, предназначенная для упрощения процесса разработки и развертывания приложений на основе Spring Framework. Основные задачи и особенности Spring Boot включают:

1. **Автоконфигурация**: Spring Boot автоматически настраивает ваше приложение на основе добавленных зависимостей, что снижает необходимость в явной конфигурации. Предоставляет «типовую» конфигурацию компонентов на основе автоконфигураций;

2. **Встроенный сервер**: Позволяет запускать веб-приложения без необходимости развертывания на внешних серверах приложений. Spring Boot поддерживает встроенные серверы, такие как Tomcat, Jetty и Undertow.

3. **Управление зависимостями**: Spring Boot упрощает управление зависимостями, предоставляя готовые "стартеры", которые объединяют зависимости для определенной функциональности, такой как JDBC, JPA, Spring Security и другие.

4. **Продакшн-готовность**: Включает различные фичи для мониторинга и управления приложением в продакшен-окружении, такие как метрики, проверки состояния и внешний конфиг.

5. **Легкость создания исполняемых JAR-файлов**: Способность создавать "fat" (или "uber") JAR-файлы, которые включают в себя не только ваше приложение, но и все его зависимости, а также встроенный сервер.

6. **Внешние конфигурации**: Упрощает управление конфигурациями приложения с помощью внешних файлов конфигурации (application.properties или application.yml), что позволяет изменять поведение приложения без изменения кода.

7. **Профили Spring**: Поддержка профилей Spring для разделения конфигурации приложения на разные среды, такие как разработка, тестирование и продакшн.

8. **Логирование**: Spring Boot предоставляет готовые настройки логирования, которые можно легко настроить с помощью внешних файлов конфигурации.

9. **Безопасность**: Включение и настройка Spring Security для обеспечения безопасности веб-приложений становится проще благодаря специализированным "стартерам".

Spring Boot значительно упрощает процесс разработки приложений на Spring, сокращая время настройки и конфигурации, и позволяя разработчикам сосредоточиться непосредственно на бизнес-логике приложения.


### 3. 


## Билет 7

### 1. Handler Mapping в Spring Web MVC

- Механизм, позволяющий распределять запросы по различным обработчикам.
- Помимо «основного» Handler'а, в обработке запроса могут участвовать один или несколько «перехватчиков» (реализаций интерфейса HandlerInterceptor).
- Механизм в общем похож на сервлеты и фильтры.
- «Из коробки» программисту доступно несколько реализаций Handler Mapping.

Некоторые реализации: RequestMappingHandlerMapping, BeanNameUrlHandlerMapping, ControllerClassNameHandlerMapping. Чаще всего используется первый. Анализирует аннотации @RequestMapping и сопоставляет запросы с соответствующими методами.

### 2. JSX. Особенности синтаксиса. Применение в React
- Расширение языка JavaScript
- Сахар для React.createElement(component, props, ...children)
- Компилируется Babel’ом в JS
- Визуально близок к HTML
- Компоненты должны возвращать всегда 1 элемент
- Все теги должны быть закрытыми (<img> -> <img />)
- Почти все теперь в camelCase (className, onClick)
- Под капотом превращается в JS
- Применяется для переиспользования компонентов, условного рендеринга, циклов.

Пример синтаксиса:
```js
class Hello extends React.Component {
render() {
return <div> Hello ${this.props.name}</div>
}
}
ReactDOM.render(
<Hello name=”Вася”/>,
document.getElementById('root')
);
```

### 3.

## Билет 8

### 1. Spring MVC: обработка запроса, dispatcher servlet

Spring MVC основан на сервлетах. Существует диспетчер сервлет, который по маппингу делегирует обработку запросу какому-то методу контроллера. Реализует паттерн MVC.
- После получения HTTP-запроса DispatcherServlet обращается к интерфейсу HandlerMapping, который определяет, какой контроллер должен быть вызван, после чего, отправляет запрос в нужный контроллер.
- Контроллер принимает запрос и вызывает соответствующий метод. Вызванный метод определяет данные модели и возвращает в DispatcherServlet имя View.
- При помощи интерфейса ViewResolver DispatcherServlet определяет, какой view нужно использовать на основании полученного имени.
- После того, как View создан, DispatcherServlet отправляет данные модели в виде атрибутов в view, который в конечном итоге отображается в браузере.


**DispatcherServlet**:
- Обрабатывает все запросы и формирует ответы на них.
- Связывает между собой все элементы архитектуры Spring MVC.
- Обычный сервлет – конфигурируется в web.xml.

### 2. SPA особенности, плюсы и минусы

**Основные идеи:**
- Все веб приложение - единый веб документ
- Обновление документа при помощи AJAX
- Роутинг через Browser History API
- Клиент и сервер реализуются независимо, управляют своим состоянием независимо и взаимодействуют по REST.
- Формат передаваемых данных не специфицирован, но обычно это JSON.

**Преимущества**:
- Быстродействие, т. к. все необходимые ресурсы загружаются при первой загрузке страницы
- Оффлайн режим
- Независимая разработка фронта и бэка
- Улучшенная навигация
- Экономия трафика

**Недостатки**:
- Большинство контента загружается динамически через JS
- Следовательно, проблемы с SEO, аналитикой, security
- Следовательно, не работает при отключенном JS

### 3. 

## Билет 9

### 1. JNDI. JNDI в Java EE. Способы взаимодействия с JNDI. Их преимущества и недостатки.

Java Naming and Directory Interface (JNDI) — это набор Java API, организованный в виде службы
каталогов, который позволяет Java-клиентам открывать и
просматривать данные и объекты по их именам. 

В контексте Java EE, JNDI используется для поиска и управления ресурсами, такими как JDBC-источники данных, JMS (Java Message Service) соединения и EJB (Enterprise JavaBeans).


**JNDI в Java EE:**

1. **Локализация ресурсов**: JNDI позволяет приложениям находить данные и объекты через логические имена, а не через конкретные ссылки или пути. Это обеспечивает гибкость и упрощает управление ресурсами в распределенной среде.

2. **Интеграция с контейнером**: В Java EE контейнер предоставляет реализацию JNDI, позволяя приложениям легко находить и использовать ресурсы, которые контейнер управляет и конфигурирует.

**Два варианта использования JNDI:**
- CDI (аннотации) — работает только в managed компонентах. В Java EE JNDI часто используется в сочетании с внедрением зависимостей, позволяя автоматически вставлять ресурсы непосредственно в компоненты приложения. Аннотации CDI позволяют автоматизировать процесс поиска и инъекции ресурсов в управляемые компоненты (managed components), такие как EJB, сервлеты или JSF бины.
- Прямой вызов API — работает везде. В явном виде выполняется поиск и работа с ресурсами через JNDI API.

### 1. Прямой доступ к JNDI

Этот подход включает использование JNDI API для непосредственного поиска ресурсов.

#### Плюсы:
- **Гибкость**: Предоставляет полный контроль над тем, как и когда осуществляется доступ к ресурсам.
- **Универсальность**: Подходит для любых типов ресурсов, доступных через JNDI.

#### Минусы:
- **Сложность**: Требует написания дополнительного кода и обработки исключений.
- **Тесная связь с JNDI**: Код становится зависимым от JNDI, что может усложнить тестирование и миграцию.

### 2. Использование Resource Injection

Современные Java EE фреймворки (например, Spring) позволяют инжектировать ресурсы из JNDI напрямую в компоненты с использованием аннотаций.

#### Плюсы:
- **Простота и Читаемость**: Уменьшает количество шаблонного кода и упрощает его понимание.
- **Легкость Интеграции**: Хорошо интегрируется с фреймворками и контейнерами, упрощая конфигурацию и управление.

#### Минусы:
- **Зависимость от контейнера**: Требуется поддержка контейнера для инъекции ресурсов.
- **Меньший контроль**: Разработчики могут иметь меньше контроля над процессом поиска и получения ресурсов.

### 2. React - особенности, плюсы и минусы использования
React - js библиотека для построения UI. 

**Особенности**
- Компоненты и их переиспользование. Каждый компонент представляет собой независимый блок кода, который отвечает за определенную часть пользовательского интерфейса. 
- Декларативность
- JSX разметка: под капотом превращается в JS, компоненты должны возвращать всегда 1 элемент, все в camelCase, закрытые теги
- Легкая интеграция в существующие решения
- Можно писать нативные и фулстек приложения

React, популярная JavaScript библиотека для создания пользовательских интерфейсов, особенно веб-приложений, имеет свои плюсы и минусы. Понимание этих аспектов важно для принятия решения о том, подходит ли React для конкретного проекта.

### Плюсы React:

1. **Компонентный Подход**: React использует компонентный подход, который помогает в построении переиспользуемого и удобно поддерживаемого кода. Компоненты могут быть инкапсулированы, что облегчает управление состоянием и логикой.

2. **Виртуальный DOM**: React использует виртуальный DOM, что обеспечивает оптимизацию производительности. Изменения сначала применяются к виртуальному DOM, а затем, с помощью эффективного алгоритма сравнения, минимально необходимые изменения вносятся в реальный DOM.

3. **Широкое Сообщество и Экосистема**: Огромное сообщество разработчиков и множество доступных ресурсов, библиотек и инструментов.

4. **Гибкость и Интеграция**: React можно использовать в сочетании с различными архитектурами и библиотеками (например, с Redux для управления состоянием).

5. **Поддержка Одностраничных Приложений (SPA)**: React идеально подходит для создания быстрых и интерактивных одностраничных приложений.

### Минусы React:

2. **Только Библиотека, а Не Полноценный Фреймворк**: React отвечает только за слой представления (вид), в отличие от полноценных фреймворков типа Angular, которые предлагают более широкий набор инструментов "из коробки".

5. **Управление Состоянием**: Управление состоянием в крупных приложениях может стать сложным без использования дополнительных библиотек, таких как Redux.

6. **SEO Оптимизация**: Для одностраничных приложений на React может потребоваться дополнительная работа для оптимизации под поисковые системы

### 3.

## Билет 10

### 1. Профили платформы Java/Jakarta EE.

Java EE представляет собой набор спецификаций, предназначенных для разработки масштабируемых, многоуровневых, надежных и безопасных сетевых приложений. В рамках Java EE существуют различные профили, каждый из которых предназначен для определенных целей и задач

### Основные Профили Java EE:

1. **Full Profile**: 
   - **Описание**: Полная платформа Java EE включает в себя все спецификации Java EE, предоставляя полный набор возможностей для создания корпоративных приложений.
   - **Ключевые Технологии**: EJB (Enterprise JavaBeans), JPA (Java Persistence API), JMS (Java Message Service), JAX-RS (Java API for RESTful Web Services), JAX-WS (Java API for XML-Based Web Services), JSF (JavaServer Faces) и другие.
   - **Использование**: Идеально подходит для крупных, многоуровневых корпоративных приложений, требующих широкой функциональности и интеграции различных компонентов.

2. **Web Profile**: 
   - **Описание**: Профиль Web представляет собой упрощенный набор спецификаций, ориентированный на веб-приложения. Он включает основные технологии, необходимые для разработки веб-приложений, без более сложных и тяжеловесных компонентов, характерных для полной платформы.
   - **Ключевые Технологии**: Servlets, JSP (JavaServer Pages), JSF, JPA, JTA (Java Transaction API), CDI (Contexts and Dependency Injection), Bean Validation.
   - **Использование**: Подходит для разработки веб-приложений, где не требуется полный набор спецификаций Java EE.
  

### 2. Способы реализации DI в Spring. @Qualifier.

**Через конструктор:**

Просто передаем бин конструктору. Если несколько конструкторов, то нужно указать @Autowired к какому-то конструктору, чтобы Спринг знал, какой использовать для внедрения зависимостей. Рекомендуется для внедрения обязательных зависимостей.

**Через сеттер:**
Спринг вызовет этот метод для внедрения зависимостей. Рекомендуется использовать для внедрения опциональных зависимостей.

**Через поле:**
Спринг просто внедрит зависимость в это поле. Часто используется из-за своей простоты и удобства, так как не требует написания дополнительного кода. Не рекомендуется использовать Field Injection для обязательных зависимостей из-за сложности в тестировании и потенциальных проблем с порядком инициализации. Также не может использоваться для присвоения зависимостей final полям.


Аннотация @Qualifier в Spring Framework используется для уточнения выбора бина при внедрении зависимостей, когда в контексте приложения существует более одного бина одного и того же типа. Это позволяет более точно указать, какой именно бин должен быть внедрен, предотвращая возможные конфликты и ошибки.

Можно определить квалификаторы, аннотируя бины с @Qualifier и указывая уникальное имя. Это имя затем используется для идентификации нужного бина при внедрении зависимостей.

```java
Copy code
@Component
@Qualifier("mainDataService")
public class MainDataService implements DataService {
    // ...
}

@Component
@Qualifier("secondaryDataService")
public class SecondaryDataService implements DataService {
    // ...
}
```

### 3. 


## Билет 11

### 1. Построение пользовательского интерфейса в JSF. Иерархия компонентов JSF

Интерфейс строится из компонентов. 
- Компоненты расположены на Facelets-шаблонах или страницах JSP. 
- Компоненты реализуют интерфейс javax.faces.component.UIComponent. 
- Можно создавать собственные компоненты.
- Компоненты на странице объединены в древовидную структуру — представление. 
- Корневым элементов представления является экземпляр класса javax.faces.component.UIViewRoot.

Сам шаблон интерфейса располагается на Facelets и состоит из комбинации различных тегов. Можно создавать свои компоненты отнаследовав их от необходимого класса/интерфейса и встраивать в facelets

### 2. CDI Beans: принципы инъекции. Способы разрешения ситуации неоднозначных зависимостей (2 бина реализуют 1 интерфейс)

CDI (Contexts and Dependency Injection) в Java EE и Jakarta EE предоставляет мощные возможности для управления зависимостями и жизненным циклом бинов. Основной принцип инъекции заключается в автоматическом управлении зависимостями между компонентами, что упрощает разработку и поддержку приложений.

### Принципы Инъекции в CDI

1. **Автоматическое Внедрение**: CDI контейнер автоматически внедряет зависимости в бины через конструкторы, сеттеры или поля.
2. **Типобезопасность**: CDI обеспечивает типобезопасность при внедрении, что снижает риск ошибок во время выполнения.
3. **Контекстная Зависимость**: Бины могут быть связаны с определенными контекстами (например, запросом, сессией), что позволяет управлять их жизненным циклом.

### Разрешение Неоднозначных Зависимостей

Когда два или более бина реализуют один интерфейс, возникает неоднозначность зависимостей. Для разрешения этой ситуации в CDI есть несколько способов:

1. **Аннотация @Default**: Используется по умолчанию, когда не указано другое квалификационное имя. Если один из бинов отмечен как `@Default`, CDI будет использовать его, когда точный квалификатор не указан.

2. **Создание Собственных Квалификаторов**:
   - Определите собственный квалификатор с аннотацией `@Qualifier`.
   - Примените этот квалификатор к нужному бину.
   - Укажите тот же квалификатор при внедрении зависимости.

   ```java
   @Qualifier
   @Retention(RUNTIME)
   @Target({METHOD, FIELD, PARAMETER, TYPE})
   public @interface MyQualifier {}

   @MyQualifier
   public class MyBeanImpl implements MyInterface {}

   @Inject
   @MyQualifier
   private MyInterface myBean;
   ```

3. **Аннотация @Alternative**:
   - Отметьте один из бинов как `@Alternative`.
   - Активируйте этот альтернативный бин в файле `beans.xml`.

   ```java
   @Alternative
   public class AlternativeBeanImpl implements MyInterface {}

   <!-- В beans.xml -->
   <beans>
       <alternatives>
           <class>com.example.AlternativeBeanImpl</class>
       </alternatives>
   </beans>
   ```

4. **Использование @Named**:
   - Используйте аннотацию `@Named` для присвоения бинам уникальных имен.
   - Внедрите зависимость, указав имя с помощью аннотации `@Inject`.

   ```java
   @Named("myNamedBean")
   public class MyBeanImpl implements MyInterface {}

   @Inject
   @Named("myNamedBean")
   private MyInterface myBean;
   ```

### 3.

## Билет 12

### 1. Ангуляр: шаблоны, представление

**Шаблоны (Templates)**
Шаблоны в Angular - это HTML-представления, которые используют Angular-расширения. Они могут включать директивы, привязки данных и другие конструкции Angular.

- Директивы: Указания Angular о том, как должен работать DOM при изменении данных. По своей реализации директивы практически идентичны компонентам (компонент — это директива с HTML-шаблоном). Есть два вида директив: структурные (добавляют, удаляют или заменяют элементы в DOM. Примеры: *ngIf, *ngFor) и атрибуты (задают элементу другое поведение. Примеры: [ngStyle], [ngClass]).
- Привязка данных: Механизмы, позволяющие связывать свойства в классе компонента с элементами в шаблоне. Существует несколько форм привязки данных:
  - Интерполяция: {{ value }}
  - Свойство: [property]="value"
  - Событие: (event)="handler()"
  - Двусторонняя: [(ngModel)]="value"
> Подробнее про привязку в одном из предыдущих вопросов
- Пайпы (Pipes): Позволяют осуществлять преобразование формата отображаемых данных (например, дат или денежных сумм) прямо в шаблоне. Например, {{ date | date:'shortDate' }} преобразует объект Date в короткую дату. Фильтры можно объединять в последовательности (pipe chains). 


**Представления (Views)**
Представления - это то, что создается на основе шаблонов и модели данных компонента при рендеринге компонента. 
- Компоненты и их шаблоны формируют представления
- Компонент может содержать *иерархию представлений*, которая содержит *встроенные представления* из других компонентов
- Каждый компонент содержит *корневое представление* (host view)

### 2. Спринг Бут, зачем он нужен. Стартеры

Зачем нужен - в 6м билете

**Стартеры**

Стартеры в Spring Boot — это набор удобных зависимостей, которые можно добавить в проект, чтобы получить функциональность, связанную с определенной технологией или задачей, без необходимости вручную определять совместимые версии каждой библиотеки. Эти стартеры упрощают процесс конфигурации проекта, предоставляя предварительно настроенные зависимости, которые работают вместе "из коробки".

### Ключевые особенности стартеров в Spring Boot:

1. **Упрощение зависимостей**: Стартеры содержат группу совместимых зависимостей, упрощая процесс настройки.
2. **Автоматическая конфигурация**: Благодаря Spring Boot автоконфигурации, стартеры помогают автоматически настроить проект в соответствии с добавленными зависимостями.
3. **Совместимость версий**: Стартеры обеспечивают совместимость между различными библиотеками, устраняя проблемы совместимости версий.

### Примеры популярных стартеров Spring Boot:

- **spring-boot-starter-web**: Для создания веб-приложений, включая RESTful приложения, использующих Spring MVC. Включает в себя Tomcat как встроенный контейнер сервлетов.
- **spring-boot-starter-data-jpa**: Для использования Spring Data JPA с Hibernate для работы с реляционными базами данных.
- **spring-boot-starter-security**: Для интеграции Spring Security в приложение.
- **spring-boot-starter-test**: Для тестирования приложений Spring Boot с помощью библиотек, таких как JUnit, Hamcrest и Mockito.
- **spring-boot-starter-thymeleaf**: Для использования шаблонизатора Thymeleaf в веб-приложениях.
- **spring-boot-starter-actuator**: Предоставляет продакшн-готовые функции для мониторинга и управления приложением.
- **spring-boot-starter-mail**: Для отправки электронной почты.

### 3.

## Билет 13

### 1. MVC-модель JSF.

**Controller** в JSF – FacesServlet, главный сервлет в JSF, обрабатывает запросы с браузера, формирует объекты-события и вызывает методы-слушатели. Конфигурируется в web.xml

**View**: JSF-страницы (XHTML или JSP).
- Интерфейс строится из компонентов.
- Компоненты расположены на Facelets-шаблонах или страницах JSP, реализуют интерфейс javax.faces.component.UIComponent.
- Можно создавать собственные компоненты.
- Компоненты на странице объединены в древовидную структуру — представление.

**Model**: Managed beans. Вместо них можно использовать CDI, EJB или Spring бины.
- Конфиг с помощью аннотаций или устаревшего xml.
- Содержат параметры и методы для обработки данных с компонентов.
- Используются для обработки событий UI и валидации данных.
- Жизненным циклом управляет JSF Runtime Environment.

### 2. Java\Jakarta EE CDI Beans: основные аннотации.

- @Named для именования бинов
- @Inject как @Autowired в Spring, для внедрения зависимостей
- @Alternative позволяет указывать конкретную реализацию интерфейса/абстрактного класса на лету для использования разных реализаций в разных ситуациях
- @Produces, @Disposes – методы для создания и уничтожения бинов соответственно (@Disposes помечается параметр метода)
- @Observes – используется в методе-наблюдателе для обработки события, помечается параметр метода
- @Stereotype - аннотации, включающие в себя другие аннотации. Используются в больших и сложных приложениях, где есть много бинов, выполняющих схожие действия.

Стереотип может задавать:
- Контекст (scope) по-умолчанию.
- Любое число назначенных перехватчиков.
- Опционально – аннотацию @Named, специфицирующую имя, под которым бин будет виден из EL.
- Опционально – аннотацию @Alternative, специфицирующую то, что бины внутри этого стереотипа являются альтернативами друг другу.

Interceptors – классы, реагирующие на определенные события ЖЦ бинов, например @PostConstruct, @PreDestroy, @AroundInvoke и т.д. Похожи на фильтры в сервлетах.

### 3.

## Билет 14

### 1. Платформы Java. Особенности, сходства и различия

Java является универсальным языком программирования, который используется в различных областях, начиная от встроенных систем и заканчивая крупномасштабными предприятиями. Платформы Java различаются по своему назначению и предоставляемому функционалу, и включают в себя следующие основные категории:

### 1. Java Standard Edition (Java SE)

- **Особенности**: Является стандартной платформой для разработки и запуска приложений на языке Java. Включает в себя базовый набор библиотек и API, таких как коллекции, потоки ввода-вывода, утилиты для работы с сетью, базовые инструменты для графического интерфейса (Swing и JavaFX) и другие основные компоненты.
- **Использование**: Разработка настольных приложений, консольных утилит, базовых серверных компонентов.

### 2. Java Enterprise Edition (Java EE) / Jakarta EE

- **Особенности**: Расширяет Java SE, добавляя библиотеки и API для разработки и запуска масштабируемых, многоуровневых, надежных и безопасных корпоративных приложений. Включает в себя такие технологии, как Servlets, JavaServer Pages (JSP), Enterprise JavaBeans (EJB), RESTful и SOAP веб-сервисы и другие.
- **Использование**: Разработка крупномасштабных предприятий и веб-приложений, систем электронной коммерции, корпоративных систем.

### 3. Java Micro Edition (Java ME)

- **Особенности**: Оптимизирована для мобильных устройств и встроенных систем. Включает в себя подмножество функционала Java SE и дополнительные библиотеки, специфичные для мобильных устройств и встроенных систем.
- **Использование**: Разработка приложений для мобильных телефонов, смарт-устройств, встроенных систем.

### Сходства и Различия

- **Сходства**:
  - Все платформы базируются на языке Java, что обеспечивает единообразие синтаксиса и основных принципов программирования.
  - Основаны на концепции "Write Once, Run Anywhere" (WORA), предполагающей кросс-платформенность.
  - Используют виртуальную машину Java (JVM) для выполнения скомпилированного байт-кода.

- **Различия**:
  - **Java SE** ориентирована на стандартные приложения, включая настольные и серверные приложения.
  - **Java EE / Jakarta EE** расширяет Java SE, предоставляя дополнительные инструменты и API для разработки и развертывания крупных корпоративных приложений.
  - **Java ME** предназначена для мобильных и встроенных устройств с ограниченными ресурсами и предлагает API, специфичные для такого рода устройств.


### 2. Двухфазные и Трёхфазные конструкторы в Spring, JavaEE

Три фазы:
- Сам конструктор, вызываемый при создании экземпляра бина
- Метод, который должен быть выполнен после завершения конструктора и внедрения всех зависимостей
- BeanPostProcessor - интерфейс Spring, который предоставляет возможность вмешиваться в жизненный цикл бина, предварительно и после его инициализации

Java EE: двухфазный конструктор – сам конструктор и метод @PostConstruct.

Spring: можно сделать трехфазный конструктор – собственно конструктор, метод @PostConstruct, и написать свой BeanPostProcessor, который будет производить дополнительные действия с бином до/после инициализации.

### 3.

## Билет 15

### 1. Валидация JSF. Создание, назначение и виды валидации.

- Осуществляется перед обновлением значения
компонента на уровне модели.
- Класс, осуществляющий валидацию, должен
реализовывать интерфейс
javax.faces.validator.Validator.
- Существуют стандартные валидаторы для
основных типов данных.
- Можно создавать собственные валидаторы.

**Способы валидации:**
- С помощью параметров компонента (аттрибут `required="true"`)
- С помощью вложенного тега (пример: вложенный в `<h:inputText>` тег `<f:validateDoubleRange minimum="-5" maximum="5"/>`)
- С помощью логики на уровне managed bean (аннотации, кастомные методы...)

### 2. Назначение и реализация контроллера Spring MVC

Controller – обрабатывает запрос пользователя,
создаёт соответствующую модель и передаёт её
для отображения в представление.
- Класс, который связывает модель с
представлением, управляет состоянием модели.
- Помечается аннотацией @Controller.
- Класс или его методы могут быть помечены
  аннотациями, «привязывающими» их к
  определённым методам HTTP или URL (`@RequestMapping` или аннотации-сокращения типа `@GetMapping`, `@PostMapping` и т.д., чтобы маппинговать URL-адреса на конкретные методы.).
- Аннотации @RequestParam, @PathVariable, @RequestBody и другие используются для извлечения данных из запросов.

Здесь выполняется бизнес-логика, обработка данных из запроса, взаимодействие с Model (сервисы, компоненты доступа к данным и т.д.) и возвращается некоторый результат, обычно в виде имени представления и модели данных для этого представления (объект `ModelAndView`) или `ResponseEntity`.

### 3. 

## Билет 16

### 1. Spring Web MVC: View Resolvers

- Представление в Spring Web MVC может быть построено на разных технологиях.
- С каждым представлением сопоставляется его символическое имя.
- Преобразованием символических имён в ссылки на конкретные представления занимается специальный класс, реализующий интерфейс org.springframework.web.servlet.ViewResolver.
- Существует много реализаций ViewResolver для разных технологий построения представления.
- В одном приложении можно использовать несколько ViewResolver'ов.
- Требуют конфигурации, описывающей, какие резолверы умеют рендерить какие view.

### 2. Хуки в React. Что это ? Для чего нужны ?

Хуки в React — это функции, которые позволяют использовать возможности состояния и жизненного цикла React в функциональных компонентах. До появления хуков эти возможности были доступны только в классовых компонентах. Хуки были введены в React с версии 16.8 и они предоставляют более удобный и простой способ работы со состоянием и другими функциями React без написания классов.

### Какие Бывают Хуки

1. **useState**: Позволяет добавить состояние React к функциональным компонентам.
2. **useEffect**: Используется для выполнения побочных эффектов в функциональных компонентах (аналог методов жизненного цикла в классовых компонентах).
3. **useContext**: Дает возможность использовать контекст React без необходимости использования Consumer.
4. **useReducer**: Предоставляет альтернативный способ использования состояния, основанный на паттерне Reducer.
5. **useRef**: Возвращает изменяемый ref-объект.
6. **useCallback**: Возвращает мемоизированный колбэк.
7. **useMemo**: Возвращает мемоизированное значение.
8. **useImperativeHandle**: Используется в сочетании с `forwardRef` для модификации родительского компонента.
9. **useLayoutEffect**: Аналогичен `useEffect`, но вызывается синхронно после всех изменений в DOM.
10. **useDebugValue**: Используется для отображения метки для пользовательских хуков в React DevTools.


### Правила Использования Хуков

1. **Только на Верхнем Уровне**: Не используйте хуки внутри циклов, условий или вложенных функций.
2. **Только из Функциональных Компонентов React**: Не вызывайте хуки из обычных JavaScript-функций. Используйте их только в функциональных компонентах React или пользовательских хуках.

### 3. 


## Билет 17

### 1. Конвертация, реализация конвертеров в JSF.

- Используются для преобразования данных в заданный формат
- Реализуют интерфейс javax.convert.Converter
- Стандартные конверторы для основных типов данных (javax.faces.Boolean, javax.faces.DateTime, javax.faces.Double, javax.faces.Character, etc.)
- JSF также позволяет создавать собственные конверторы:

Для создания конвертера нужно реализовать интерфейс `javax.faces.convert.Converter` (Этот интерфейс требует реализации двух методов: `getAsObject()` и `getAsString()`), а потом зарегистрировать конвертер через аннотацию `@FacesConverter`


**Назначение конвертеров:**
- Автоматическое (на основании типа данных):
```<h:inputText value="#{user.age}"/>```

- С помощью атрибута converter:
```js
<h:inputText
converter="#{javax.faces.DateTime}"/>
```

- С помощью вложенного тега:
```js
<h:outputText value="#{user.birthDay}">
<f:converter
converterId="#{javax.faces.DateTime}"/>
</h:outputText>
```

### 2. Представление уровня доступа к данным с помощью Spring Data JPA. Концепция, конфигурация.

Spring Data JPA (Java Persistence API) — это часть экосистемы Spring Data, предназначенная для упрощения реализации слоя доступа к данным в приложениях. Она обеспечивает более высокоуровневый и удобный способ взаимодействия с базами данных, скрывая большую часть стандартного кода, связанного с управлением сущностями и запросами.

### Концепция

1. **Репозитории**: Основная концепция Spring Data JPA заключается в использовании интерфейсов репозиториев для определения операций с данными. Spring Data автоматически создает реализацию на основе названий методов в интерфейсе.

2. **Сущности JPA**: Сущности представляют таблицы базы данных и их поля отображаются на столбцы этих таблиц. Сущности аннотируются с помощью аннотаций из спецификации JPA (`@Entity`, `@Id`, `@Column`, и др.).

3. **Spring Data Repository**: Spring Data предоставляет различные типы репозиториев (например, `CrudRepository`, `PagingAndSortingRepository`), которые предлагают различные операции для взаимодействия с базой данных (например, сохранение, удаление, поиск).

### Конфигурация

1. **Зависимости**: Добавьте зависимости Spring Data JPA и соответствующего драйвера базы данных в ваш файл `pom.xml` (Maven) или `build.gradle` (Gradle).

   ```xml
   <!-- Для Maven -->
   <dependencies>
       <dependency>
           <groupId>org.springframework.boot</groupId>
           <artifactId>spring-boot-starter-data-jpa</artifactId>
       </dependency>
       <dependency>
           <groupId>соответствующая_база_данных</groupId>
           <artifactId>соответствующий_драйвер</artifactId>
       </dependency>
   </dependencies>
   ```

2. **Конфигурация DataSource**: Настройте источник данных в файле `application.properties` или `application.yml`. Здесь вы определите параметры подключения к базе данных, такие как URL, имя пользователя, пароль и другие настройки.

   ```properties
   spring.datasource.url=jdbc:url_базы_данных
   spring.datasource.username=имя_пользователя
   spring.datasource.password=пароль
   ```

3. **Аннотация `@Entity`**: Определите сущности JPA, аннотируя классы моделей с `@Entity`. Эти классы представляют таблицы в вашей базе данных.

   ```java
   @Entity
   public class User {
       @Id
       @GeneratedValue(strategy = GenerationType.IDENTITY)
       private Long id;

       // другие поля и методы
   }
   ```

4. **Репозиторий**: Создайте интерфейс репозитория, расширяющий один из интерфейсов Spring Data Repository. В этом интерфейсе вы можете определить пользовательские методы для доступа к данным.

   ```java
   public interface UserRepository extends JpaRepository<User, Long> {
       // Определение пользовательских запросов
       List<User> findByLastName(String lastName);
   }
   ```

### Преимущества использования Spring Data JPA

- **Уменьшение шаблонного кода**: Автоматическая реализация репозиториев устраняет необходимость в написании большинства кода CRUD.
- **Легкость в использовании**: Простота в определении запросов через названия методов.
- **Поддержка пагинации и сортировки**: Встроенные возможности для пагинации и сортировки данных.
- **Интеграция

 с JPA/Hibernate**: Spring Data JPA работает поверх стандартных JPA провайдеров, таких как Hibernate, обеспечивая мощные возможности ORM.
- **Поддержка транзакций**: Управление транзакциями через декларативные аннотации.

### 3. 

## Билет 18

### 1. Java EE/Jakarta CDI бины. Что это и зачем нужны, если есть ManagedBean и EJB

Contexts and Dependency Injection (CDI) в Java EE представляет собой мощный инструмент для управления зависимостями и контекстами в приложениях. CDI beans дополняют возможности Managed Beans и Enterprise JavaBeans (EJB), обеспечивая более гибкое управление зависимостями и более широкий спектр функций. Вот основные причины, по которым CDI beans используются наряду или вместо Managed/EJB beans:

### 1. Улучшенное Управление Зависимостями

- **Типобезопасные зависимости**: CDI позволяет более безопасно и удобно инжектировать зависимости, используя аннотации типа `@Inject`. Это делает код более чистым и устойчивым к ошибкам.
- **Квалификаторы и Продюсеры**: CDI предоставляет квалификаторы (`@Qualifier`) и продюсеры (`@Produces`), позволяя более точно управлять инъекцией зависимостей.

### 2. Гибкость и Модульность

- **Декораторы и Интерцепторы**: CDI предлагает механизмы для декорирования бинов и использования перехватчиков, что облегчает добавление перехрестной функциональности, такой как логирование и транзакции.
- **Событийная модель**: CDI поддерживает событийно-ориентированное программирование, позволяя компонентам взаимодействовать друг с другом через события.

### 3. Интеграция с Java EE

- **Единообразие в Java EE**: CDI обеспечивает стандартизированный способ управления зависимостями во всех компонентах Java EE, включая JPA, JSF, EJB и другие.
- **Портативность**: Код, написанный с использованием CDI, легко переносится между различными Java EE серверами.

### 4. Улучшенное Управление Жизненным Циклом

- **Расширенные области видимости**: CDI предлагает гибкие области видимости, включая пользовательские, что позволяет более точно управлять жизненным циклом бинов.

### 5. Замена и Дополнение к EJB

- **Легковесность**: CDI beans могут служить легковесной альтернативой EJB для некоторых задач, особенно когда не требуется полный спектр функций EJB, таких как удаленный доступ или управление транзакциями.


### 2. Java Server Faces. Что это, преимущества и недостатки

JSF — фреймворк для разработки вебприложений. 
- Входит в состав платформы Java EE.
- Основан на использовании компонентов. 
- Для отображения данных используются JSP или XML-шаблоны (facelets)

+:
- (фреймворк реализует шаблон MVC). 
- Управление обменом данными на уровне компонент. 
- Простая работа с событиями на стороне сервера. 
- Расширяемость (можно использовать дополнительные наборы компонентов). 
- Широкая поддержка со стороны интегрированных средств разработки (IDE).

-:
- Высокоуровневый фреймворк — сложно реализовывать не предусмотренную авторами функциональность. 
- Сложность разработки собственных компонентов.

### 3. 

## Билет 19

### 1. Rest контроллер: сериализация и десериализация

В Spring Framework REST контроллеры обычно реализуются с помощью аннотации `@RestController`, которая упрощает создание RESTful веб-сервисов. Сериализация и десериализация данных в этих контроллерах обычно управляется автоматически, что значительно упрощает процесс работы с JSON, XML и другими форматами данных.

### Сериализация и Десериализация:

1. **Сериализация (От сервера к клиенту)**:
   - Когда данные возвращаются из методов контроллера, Spring автоматически сериализует возвращаемые объекты в JSON (или другой формат, в зависимости от конфигурации) с использованием библиотеки, такой как Jackson.
   - Это происходит когда методы контроллера аннотированы `@ResponseBody` или когда контроллер аннотирован `@RestController` (который включает в себя `@Controller` + `@ResponseBody`).

2. **Десериализация (От клиента к серверу)**:
   - При получении запроса с телом (например, POST или PUT запросов), Spring автоматически десериализует входящие данные (например, JSON) в объекты Java, если это указано в параметрах метода контроллера с помощью аннотации `@RequestBody`.

Под капотом работает на библиотеке `Jackson`

### 2. Angular: архитектура. Модули, компоненты, сервисы и представления

Архитектура Angular приложения основана на модулях, компонентах, представлениях и сервисах. Эти концепции помогают организовать код, улучшить его читаемость, возможность масштабируемости и облегчить его поддержку.

1. Модуль - это класс с декоратором @NgModule(), который служит изолирующей логической объединяющей структурой для компонентов, директив, пайпов и сервисов. • Каждое приложение обязательно включает в себя корневой модуль (root module) под названием AppModule (файл app.module.ts). 
- Могут ссылаться друг на друга (т.е. возможны импорт и экспорт модулей)

2. Компонент - обособленная часть функционала со своей логикой, HTML- шаблоном и CSS-стилями. Компонент управляет отображение представление на экране. За объявление компонента отвечает декоратор @Component()
- Каждый компонент представляет собой независимую часть пользовательского интерфейса и описывает свое поведение, отображение данных и взаимодействие с пользователем. 

3. Представление (Views):
   - Представления представляют собой шаблоны, содержащие HTML и директивы Angular, которые определяют отображение компонентов в браузере.

4. Сервис - это класс, который является поставщиком данных,  обеспечивают общую функциональность. Сервисы инкапсулируют бизнес логику приложения. Сервисы могут предоставлять интерфейс взаимодействия между отдельными не связанными друг с другом компонентами. 
- Реализуются в виде отдельных классов в соответствии с принципами ООП. 
- Компонент может делегировать какие-либо из своих задач сервисам. 
- Доступ компонентов к сервисам реализуется с помощью DI


### 3. 

## Билет 20

### 1. FacesServlet - назначение и конфигурация

Класс FacesServlet
- Центральный компонент в архитектуре JSF, контроллер в шаблоне MVC
- Обрабатывает запросы с браузера.
- Формирует объекты-события и вызывает методы-слушатели.
- Управляет жизненным циклом запроса (прохождение через все фазы)
- Конфигурация задается в web.xml
- 
![image](https://github.com/eliteSufferer/ITMO_Studies/assets/46615564/3acfeeef-244a-4def-bc25-bf747f8bf3c6)


Пример конфигурации:

```xml
<!-- Faces Servlet -->
<servlet>
<servlet-name>Faces Servlet</servlet-name>
<servlet-class>javax.faces.webapp.FacesServlet</servlet-class>
<load-on-startup>1</load-on-startup>
</servlet>
<!-- Faces Servlet Mapping -->
<servlet-mapping>
<servlet-name>Faces Servlet</servlet-name>
<url-pattern>/faces/*</url-pattern>
</servlet-mapping>
```

### 2. React - особенности, плюсы и минусы использования

См. Билет 9

### 3. 

## Билет 21

### 1. Структура JSF приложения

- JSP или XHTML-страницы, содержащие компоненты GUI.
- Библиотеки тегов.
- Управляемые бины.
- Дополнительные объекты (компоненты, конвертеры и валидаторы).
- Дополнительные теги.
- Конфигурация — faces-config.xml (опционально).
- Дескриптор развёртывания — web.xml.

### 2. Spring Web MVC: особенности, реализация, интегрирование с серверами приложений Java/Jakarta EE

### 3.

## Билет 22

### 1. Spring бины.@Component, стереотипы

В Spring Framework, бины — это объекты, которые формируют основу вашего приложения и управляются контейнером Spring IoC (Inversion of Control). Для удобства работы с бинами в Spring были введены аннотации стереотипов. Они не только помогают в автоматическом определении бинов в контексте Spring, но и указывают на их роль в приложении. Наиболее распространенные аннотации стереотипов — это `@Component`, `@Service`, `@Repository`, и `@Controller`.

### @Component

- **Описание**: Это общая аннотация, указывающая, что класс является компонентом Spring. Классы, помеченные этой аннотацией, автоматически обнаруживаются сканированием путей классов и регистрируются в контексте Spring как бины.
- **Использование**: Используется для классов, которые не попадают под более конкретные стереотипы (`@Service`, `@Repository`, `@Controller`).

### @Service

- **Описание**: Специализированная форма `@Component`, используемая в слое сервисов. Она указывает на классы, которые выполняют бизнес-логику.
- **Использование**: Применяется к классам, которые содержат бизнес-логику. Это помогает в документировании и организации кода, а также может быть использовано для специальной обработки в рамках контейнера.

### @Repository

- **Описание**: Еще одна специализированная версия `@Component`, предназначенная для слоя доступа к данным, обычно используемого для взаимодействия с базой данных.
- **Использование**: Обозначает классы, которые осуществляют операции с базой данных, например, через JPA или Hibernate. Особенностью `@Repository` является возможность автоматической обработки исключений на уровне доступа к данным.

### @Controller

- **Описание**: Эта аннотация используется в веб-приложениях Spring MVC и обозначает классы, которые выполняют роль контроллеров в модели MVC.
- **Использование**: Применяется к классам, которые обрабатывают HTTP-запросы. Контроллеры обрабатывают входящие запросы, выполняют необходимые действия (часто с помощью сервисов) и возвращают представление.

### 2. Структура приложения React (по другой версии - Разметка в React). JSX

### 3.


## Билет 23

### 1. Фаза получения значений компонентов (Apply Request Values Phase)

После фазы формирования представления и перед фазой валидации.

- На стороне клиента все значения хранятся в строковом формате — нужна проверка их корректности:
- Вызывается конвертер в соответствии с типом данных значения.
- Если конвертация заканчивается успешно, значение сохраняется в локальной переменной компонента.
- Если конвертация заканчивается неудачно, создаётся сообщение об ошибке, которое помещается в FacesContext.

### 2. Реализация IoC и CDI в Spring

**В общих чертах**

Объекты не создаются и не управляются напрямую программистом, а передаются контейнеру (например, в Spring ApplicationContext), для управления их ЖЦ.
DI: внедрять зависимости можно через конструктор, поле или сеттер, пометив их @Autowired.

**Про DI**
В Spring Framework внедрение зависимостей (Dependency Injection, DI) — это ключевая концепция, которая используется для создания слабо связанных приложений. DI в Spring позволяет инжектировать объекты (зависимости) в классы, не создавая их явно в коде. Вместо этого, Spring контейнер заботится об этом, используя конфигурацию, заданную либо в XML, либо с помощью аннотаций, либо через Java-конфигурацию.

Вот как это работает:

1. **Контейнер IoC (Inversion of Control)**: В основе Spring DI лежит IoC контейнер, который управляет созданием и жизненным циклом бинов (объектов), зарегистрированных в контейнере.

2. **Аннотации для DI**:
   - `@Autowired`: Автоматически инжектирует бин по типу. Может использоваться на полях, сеттерах и конструкторах.
   - `@Qualifier`: Указывает, какой именно бин следует инжектировать, когда имеется несколько кандидатов одного и того же типа.
   - `@Resource`: Похож на `@Autowired`, но инжекция происходит по имени бина.
   - `@Inject`: Стандарт JSR-330 для инъекции зависимостей, похож на `@Autowired`.

3. **Конструктор, Сеттеры, и Поля для Инъекции**:
   - **Инъекция через конструктор**: Преимущества в том, что объект создается сразу со всеми необходимыми зависимостями, идеально подходит для обязательных зависимостей.
   - **Инъекция через сеттеры**: Используется для необязательных зависимостей.
   - **Инъекция в поля**: Хотя это удобно, не рекомендуется из-за того, что оно нарушает инкапсуляцию и затрудняет тестирование.

4. **XML-конфигурация**:
   - Ранее Spring использовал XML файлы для конфигурации бинов, но этот подход становится все менее популярным в пользу аннотаций и Java-конфигурации.

5. **Java-конфигурация**:
   - `@Configuration`: Классы с этой аннотацией определяют бины контейнера Spring.
   - `@Bean`: Методы с этой аннотацией возвращают объекты, которые автоматически регистрируются как бины в Spring контейнере.

6. **Profiles**:
   - `@Profile`: Определяет, при каких условиях бин должен быть активирован.

7. **Scope**:
   - `@Scope`: Определяет область видимости бина, такую как singleton (по умолчанию), prototype и другие.


**Про IoC**

Inversion of Control (IoC) в Spring Framework реализуется через IoC контейнер. Контейнер управляет созданием объектов, их жизненным циклом и конфигурацией зависимостей. В Spring IoC контейнер достигается через два основных интерфейса: `BeanFactory` и более расширенный `ApplicationContext`.

### Реализация IoC в Spring:

1. **Конфигурация**:
   - В Spring IoC можно настроить с помощью XML, аннотаций или Java-конфигурации. Разработчики могут выбрать один из этих подходов или комбинацию в зависимости от требований проекта.

2. **Bean Definitions**:
   - В конфигурации бинов определяются метаданные, которые IoC контейнер использует для создания и управления бинами и их зависимостями.

3. **Bean Scopes**:
   - Spring поддерживает различные области видимости для бинов, например, singleton (один экземпляр на контейнер), prototype (новый экземпляр для каждого запроса) и другие.

4. **Bean Lifecycle**:
   - Spring управляет полным жизненным циклом бинов, от создания до уничтожения. Разработчики могут вмешаться в этот процесс, используя аннотации или интерфейсы, такие как `InitializingBean`, `DisposableBean`, или кастомные методы с аннотациями `@PostConstruct` и `@PreDestroy`.

5. **Dependency Resolution**:
   - Зависимости между бинами разрешаются контейнером IoC либо автоматически (автопроводка), либо конфигурационно, в зависимости от того, какие бины требуются другим бинам для их работы.

6. **Event Handling**:
   - Spring IoC контейнер также предоставляет поддержку событий и слушателей, что позволяет бинам реагировать на события внутри приложения.

