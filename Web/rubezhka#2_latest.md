## Билет 1

### 1. CDI бины, именование CDI бинов, @Alternative

**CDI Beans**
- Универсальные компоненты уровня бизнес-логики.
- Абстрактная реализация паттерна CDI в Java / Jakarta EE.
- «Клонируют» основные концепции бинов из Spring.
- Общая идея – «отвязаться» от конкретного фреймворка при создании бизнес-логики внутри приложения.
- Конфигурируются аннотациями, основной пакет – javax.enterprise.context.
- Для CDI используется универсальная аннотация @Inject.
- В отличие от EJB, не обеспечивают горизонтальную масштабируемость «сами по себе»
- Разные контексты (мб перчислить)

**Именование бинов**

1. Неявное Именование: По умолчанию, CDI автоматически присваивает имя бину, основываясь на имени класса с первой буквой в нижнем регистре. Например, класс PaymentService будет иметь имя бина paymentService.
2. Явное Именование с @Named: Если вам нужно использовать конкретное имя для бина, можно использовать аннотацию @Named, чтобы указать это имя. Это полезно для доступа к бинам в EL-выражениях (Expression Language) в JSF и других технологиях.


**@Alternative**

Аннотация @Alternative позволяет определить дополнительные реализации для бина, которые могут быть выбраны вместо стандартной реализации. Для активации альтернативного бина его нужно указать в файле конфигурации beans.xml. Это особенно полезно в ситуациях, когда есть несколько реализаций одного и того же интерфейса, и надо явно выбрать, какая реализация должна использоваться в определенном контексте приложения.

### 2. DI в Angular
**Dependency injection**
- Общая концепция: зависимости объекта передаются ему извне, а не создаются самим объектом
- Компоненты могут использовать сервисы с помощью DI.
- Для того, чтобы класс можно было использовать с помощью DI, он должен
содержать декоратор @Injectable()

**Основные принципы реализации DI**
- Приложение содержит как минимум один глобальный Injector, который
занимается DI.
- Injector создаёт зависимости и передаёт их экземпляры контейнеру
- Провайдер (provider) -- это объект, который сообщает Injector’у, как
получить или создать экземпляр зависимости.
- Обычно провайдером сервиса является сам его класс. Для каждого сервиса должен быть зарегистрирован как минимум один провайдер.
- Зависимости компонентов указываются в качестве параметров их конструкторов

### 3. Конфигурация Spring Web MVC без использования Spring Boot. Написать web.xml для приложения развернутого на сервере приложений Jakarta EE

## Билет 2

### 1. Location Transparency. Реализация в Java/Java EE

Location Transparency описывает концепцию, согласно которой клиентский код может вызывать методы на объекте (или сервисе) без знания физического местоположения этого объекта. Благодаря CDI не важно, где физически
расположен вызываемый компонент — за его
вызов отвечает контейнер.

В Java и Java EE, Location Transparency традиционно достигается с использованием нескольких технологий:

1. **RMI (Remote Method Invocation)**: Это базовая технология Java для взаимодействия между приложениями в сети. RMI позволяет объектам, расположенным на разных JVM, взаимодействовать друг с другом так, как будто они находятся в одной JVM.

2. **EJB (Enterprise JavaBeans)**: В рамках Java EE, EJB обеспечивает более высокоуровневый способ достижения прозрачности расположения. Stateful, Stateless и Singleton session beans могут быть доступны для клиентских приложений без информации о их физическом расположении.

3. **JNDI (Java Naming and Directory Interface)**: Используется для поиска EJB и других ресурсов в сети. Клиенты ищут сервисы по логическому имени, и JNDI обеспечивает связь с физическим расположением или конкретной реализацией сервиса.

4. **Web Services (SOAP and REST)**: Они обеспечивают еще один уровень прозрачности расположения, позволяя клиентам обращаться к сервисам через HTTP, не заботясь о деталях их реализации.

### 2. Реализация уровня представления в Spring Web MVC


### 3. Напишите реакт компонент реализующий карусель изображений поле каруселью подразумевается , отображается одно изображение из н, можно переключать кнопками вперёд и назад пролистывая изображения, хранятся на клиентском устройстве, список путей к файлам передавать через props

## Билет 3

### 1. RMI. Реализация RMI в Java EE



## Билет 4

### 1. Управляемые бины - назначение, способы конфигурации, доступ из jsp/xhtml

**Назначение**
- Содержат параметры и методы для обработки данных с компонентов.
- Используются для обработки событий UI и валидации
данных.
- Жизненным циклом управляет JSF Runtime
Envronment.
- Есть разные контексты (Request, Session, Application...)
- Доступ из JSF-страниц осуществляется с помощью
элементов EL.
- Конфигурация задаётся в faces-config.xml (JSF 1.X),
либо с помощью аннотаций (JSF 2.0).
- Вместо них могут использоваться CDI-бины, EJB или
бины Spring.

**Конфигурация**

1. Способ 1 — через faces-config.xml:

```xml
<managed-bean>
<managed-bean-name>customer</managed-bean-name>
<managed-bean-class>CustomerBean</managed-bean-class>
<managed-bean-scope>request</managed-bean-scope>
<managed-property>
<property-name>areaCode</property-name>
<value>#{initParam.defaultAreaCode}</value>
</managed-property>
</managed-bean>
```

2. Способ 2 (JSF 2.0) — с помощью аннотаций:

```java
@ManagedBean(name="customer")
@RequestScoped
public class CustomerBean {
...
@ManagedProperty(value="#{initParam.defaultAreaCode}"
name="areaCode")
private String areaCode;
...
}
```

**Использование**

Доступ к управляемым бинам со страниц приложения осуществляется с помощью EL-выражений:

```xhtml
...
<h:inputText value="#{user.name}"
validator="#{user.validate}" />
...
<h:inputText binding="#{user.nameField}" />
...
<h:commandButton action="#{user.save}"
value="Save" />
...
```

### 2. Архитектура и состав Spring Web MVC
Spring Web MVC – “базовый” фреймворк в составе Spring для разработки веб-приложений, основан на паттерне MVC; универсальный, удобен для
разработки REST API.

**Архитекутра**

![image](https://github.com/eliteSufferer/ITMO_Studies/assets/46615564/84e164fc-ca6d-4a07-bf9c-aa26a77a5c5e)

1. **HTTP Request**: Все начинается с HTTP-запроса, который отправляется на сервер.

2. **DispatcherServlet**:
   - Обрабатывает все запросы и формирует ответы на них.
   - Связывает между собой все элементы архитектуры Spring MVC.
   - Обычный сервлет – конфигурируется в web.xml.

3. **Handler Mapping (1)**:
   - Интерфейс, позволяющий распределять запросы по различным обработчикам (контроллерам).
   - Помимо «основного» Handler'а, в обработке
запроса могут участвовать один или несколько
«перехватчиков» (реализаций интерфейса HandlerInterceptor).
  - Механизм в общем похож на сервлеты и
фильтры.

4. **Controller (2)**:
   - Контроллер берет на себя обработку запроса после того, как `Handler Mapping` определяет, что он должен этим заниматься.
   - Здесь выполняется бизнес-логика, обработка данных из запроса, взаимодействие с Model (сервисы, компоненты доступа к данным и т.д.) и возвращается некоторый результат, обычно в виде имени представления и модели данных для этого представления (объект `ModelAndView`).

5. **View Resolver (3)**:
   - Представление в Spring Web MVC может быть построено
на разных технологиях, с каждым представлением сопоставляется его
символическое имя.
   - Преобразованием символических имён в ссылки на
конкретные представления занимается специальный
класс, реализующий интерфейс
org.springframework.web.servlet.ViewResolver.
   - В одном приложении можно использовать несколько
ViewResolver'ов.
   - После того, как контроллер выполнит свою работу, `View Resolver` определяет, какое представление должно быть использовано для отображения результатов выполнения.
   - Он преобразует логическое имя представления, предоставленное контроллером, в фактический путь к файлу представления (например, к файлу JSP).

1. **View (4)**:
   - Представление отвечает за отображение ответа пользователю. Это может быть страница JSP, HTML и т.д., которая рендерит данные, предоставленные контроллером.
   - После рендеринга представление (View) возвращается обратно в `DispatcherServlet`.

2. **HTTP Response**:
   - Наконец, `DispatcherServlet` отправляет сформированный ответ обратно клиенту.

Эта схема демонстрирует, как Spring MVC следует паттерну "Front Controller", где `DispatcherServlet` играет центральную роль в координации процесса обработки запроса, взаимодействия с компонентами бизнес-логики и подготовке ответа для клиента.
**Состав приложения**

- Model:
  - Хранит данные, необходимые для
    формирования представления.
  - Сами по себе эти данные – обычные POJO.
  - В общем случае, реализует интерфейс
    org.springframework.ui.Model.
  - Есть «упрощённая» реализация,
    представляющая из себя Map - org.springframework.ui.ModelMap.
- View – отвечает за отображение данных модели.
  - Фреймворк не специфицирует жёстко
  технологию, на которой должно быть построено
  представление.
  - Вариант «по-умолчанию» – JSP.
  - Можно использовать Thymeleaf, FreeMarker, etc.
  - Можно реализовать представление вне
  контекста Spring – целиком на JS.
- Controller – обрабатывает запрос пользователя,
создаёт соответствующую модель и передаёт её
для отображения в представление.
  - Класс, который связывает модель с
представлением, управляет состоянием модели.
  - Помечается аннотацией @Controller.
  - Класс или его методы могут быть помечены
  аннотациями, «привязывающими» их к
  определённым методам HTTP или URL.

### 3. Интерфейс на angular, проверяющий, аутентифицирован ли пользователь(по наличию куки jsessionid), и, если нет, позволяющий ему аутентифицировться посредством ввода логина и пароля.

```ts
import { Component } from '@angular/core';
import { CookieService } from 'ngx-cookie-service';

@Component({
  selector: 'app-auth',
  template: `
    <div *ngIf="!isAuthenticated">
      <form (ngSubmit)="login()">
        <input type="text" [(ngModel)]="username" name="username" placeholder="Username">
        <input type="password" [(ngModel)]="password" name="password" placeholder="Password">
        <button type="submit">Login</button>
      </form>
    </div>
    <div *ngIf="isAuthenticated">
      <p>User is authenticated</p>
      <!-- Другие элементы пользовательского интерфейса для аутентифицированного пользователя -->
    </div>
  `
})
export class AuthComponent {
  isAuthenticated = false;
  username: string;
  password: string;

  constructor(private cookieService: CookieService) {}

  ngOnInit() {
    this.isAuthenticated = this.cookieService.check('JSESSIONID');
  }

  login() {
    // Здесь должна быть логика аутентификации
    // Например, отправка данных на сервер и установка куки JSESSIONID при успешном входе
  }
}
```

## Билет 5

### 1. Области видимости MB. Способы задания области видимости

**Сопособы конфигурации**: Задаётся через faces-config.xml или с помощью аннотаций.


Пример через faces-config:
```xml
<managed-bean>
<managed-bean-name>customer</managed-bean-name>
<managed-bean-class>CustomerBean</managed-bean-class>
<managed-bean-scope>request</managed-bean-scope>
...
```

Через аннотации:
```java
@ManagedBean(name="customer")
@RequestScoped
public class CustomerBean {
...
}
```

6 вариантов конфигурации:
- @NoneScoped — контекст не определён, жизненным
циклом управляют другие бины.
- @RequestScoped (применяется по умолчанию) — Бин создается заново при каждом HTTP запросе, используется для коротких операций, не требующих сохранения состояния между запросами.
- @ViewScoped (JSF 2.0) — Бин остается активным в течение жизни одного и того же JSF view (например, пока пользователь находится на одной и той же странице). Используется для операций, состояние которых должно сохраняться при AJAX-запросах на одной странице.
- @SessionScoped — Бин остается активным в течение всей пользовательской сессии. Используется для данных, которые должны сохраняться между различными запросами в рамках одной сессии пользователя.
- @ApplicationScoped — Бин остается активным в течение всего времени жизни приложения. Используется для данных, общих для всех пользователей приложения.
- @CustomScoped (JSF 2.0) — бин сохраняется в Map; программист сам управляет его жизненным циклом.

### 2. Принципиальные различия spring и java EE

Spring Framework и Java/Jakarta EE представляют собой две популярные платформы для разработки предприятия в экосистеме Java. Обе платформы обеспечивают обширный набор функций для создания масштабируемых и гибких приложений, но имеют ряд принципиальных отличий в подходах к реализации и архитектуре.

### Идейные отличия:
- «Базовая» концепция Java EE – разделение
обязанностей между контейнером и
компонентом; «базовая» концепция Spring – IoC /
CDI.
- Контейнер в Java EE включает в себя
приложение; приложение в Spring включает в
себя контейнер.
- Java EE – спецификация; Spring – фреймворк.

### 1. Подход к Конфигурации

- **Spring**: Использует подход "конфигурация через код" (JavaConfig), позволяя разработчикам определять бины и конфигурации непосредственно в Java-коде. Поддерживает также декларативную конфигурацию через XML и аннотации. Spring Boot дополнительно предоставляет автоматическую конфигурацию на основе классов, доступных в classpath.
- **Java/Jakarta EE**: Традиционно использовал декларативный подход с помощью XML-файлов, но современные версии Jakarta EE также широко используют аннотации и CDI (Contexts and Dependency Injection) для упрощения конфигурации.

### 2. Внедрение Зависимостей (Dependency Injection)

- **Spring**: Одна из ключевых особенностей Spring - это мощная поддержка внедрения зависимостей через аннотации (`@Autowired`) и конструкторы. Spring Boot упрощает этот процесс еще больше.
- **Java/Jakarta EE**: CDI является стандартом для внедрения зависимостей в Java EE. Он также использует аннотации (например, `@Inject`) и обеспечивает тесную интеграцию с другими компонентами Java EE.

### 3. Стандарты и Портативность

- **Spring**: Хотя Spring использует некоторые стандарты Java EE, такие как JPA для работы с базами данных, он сам по себе не является стандартом и работает как самостоятельный фреймворк.
- **Java/Jakarta EE**: Полностью основан на стандартах, что обеспечивает высокий уровень портативности между различными реализациями и серверами приложений.

### 4. Модель Программирования

- **Spring**: Предоставляет более гибкую и легкую модель программирования, что делает его популярным выбором для создания микросервисов и облачных приложений.
- **Java/Jakarta EE**: Следует более формальному подходу, основанному на стандартах, что может быть предпочтительнее в больших и строго стандартизированных корпоративных средах.


## Билет 6

### 1. Фазы Invoke Application и Render Response

Эти две фазы идут после фазы обновления значений компонентов.

**Invoke Application:**

На этом этапе реализация JavaServer Faces обрабатывает все события на уровне приложения, такие как отправка формы или переход на другую страницу.

**Render Response:**
- JSF Runtime обновляет представление в соответствии с результатами обработки запроса.
- Если это первый запрос к странице, то компоненты помещаются в иерархию представления.
- Формируется ответ сервера на запрос.
- На стороне клиента происходит обновление страницы.

### 2. Какие задачи выполняет Spring Boot

Spring Boot — это часть большой экосистемы Spring, предназначенная для упрощения процесса разработки и развертывания приложений на основе Spring Framework. Основные задачи и особенности Spring Boot включают:

1. **Автоконфигурация**: Spring Boot автоматически настраивает ваше приложение на основе добавленных зависимостей, что снижает необходимость в явной конфигурации. Предоставляет «типовую» конфигурацию компонентов на основе автоконфигураций;

2. **Встроенный сервер**: Позволяет запускать веб-приложения без необходимости развертывания на внешних серверах приложений. Spring Boot поддерживает встроенные серверы, такие как Tomcat, Jetty и Undertow.

3. **Управление зависимостями**: Spring Boot упрощает управление зависимостями, предоставляя готовые "стартеры", которые объединяют зависимости для определенной функциональности, такой как JDBC, JPA, Spring Security и другие.

4. **Продакшн-готовность**: Включает различные фичи для мониторинга и управления приложением в продакшен-окружении, такие как метрики, проверки состояния и внешний конфиг.

5. **Легкость создания исполняемых JAR-файлов**: Способность создавать "fat" (или "uber") JAR-файлы, которые включают в себя не только ваше приложение, но и все его зависимости, а также встроенный сервер.

6. **Внешние конфигурации**: Упрощает управление конфигурациями приложения с помощью внешних файлов конфигурации (application.properties или application.yml), что позволяет изменять поведение приложения без изменения кода.

7. **Профили Spring**: Поддержка профилей Spring для разделения конфигурации приложения на разные среды, такие как разработка, тестирование и продакшн.

8. **Логирование**: Spring Boot предоставляет готовые настройки логирования, которые можно легко настроить с помощью внешних файлов конфигурации.

9. **Безопасность**: Включение и настройка Spring Security для обеспечения безопасности веб-приложений становится проще благодаря специализированным "стартерам".

Spring Boot значительно упрощает процесс разработки приложений на Spring, сокращая время настройки и конфигурации, и позволяя разработчикам сосредоточиться непосредственно на бизнес-логике приложения.


### 3. 


## Билет 7

### 1. Handler Mapping в Spring Web MVC

- Механизм, позволяющий распределять запросы по различным обработчикам.
- Помимо «основного» Handler'а, в обработке запроса могут участвовать один или несколько «перехватчиков» (реализаций интерфейса HandlerInterceptor).
- Механизм в общем похож на сервлеты и фильтры.
- «Из коробки» программисту доступно несколько реализаций Handler Mapping.

Некоторые реализации: RequestMappingHandlerMapping, BeanNameUrlHandlerMapping, ControllerClassNameHandlerMapping. Чаще всего используется первый. Анализирует аннотации @RequestMapping и сопоставляет запросы с соответствующими методами.

### 2. JSX. Особенности синтаксиса. Применение в React
- Расширение языка JavaScript
- Сахар для React.createElement(component, props, ...children)
- Компилируется Babel’ом в JS
- Визуально близок к HTML
- Компоненты должны возвращать всегда 1 элемент
- Все теги должны быть закрытыми (<img> -> <img />)
- Почти все теперь в camelCase (className, onClick)
- Под капотом превращается в JS
- Применяется для переиспользования компонентов, условного рендеринга, циклов.

Пример синтаксиса:
```js
class Hello extends React.Component {
render() {
return <div> Hello ${this.props.name}</div>
}
}
ReactDOM.render(
<Hello name=”Вася”/>,
document.getElementById('root')
);
```

### 3.

## Билет 8

### 1. Spring MVC: обработка запроса, dispatcher servlet

Spring MVC основан на сервлетах. Существует диспетчер сервлет, который по маппингу делегирует обработку запросу какому-то методу контроллера. Реализует паттерн MVC.
- После получения HTTP-запроса DispatcherServlet обращается к интерфейсу HandlerMapping, который определяет, какой контроллер должен быть вызван, после чего, отправляет запрос в нужный контроллер.
- Контроллер принимает запрос и вызывает соответствующий метод. Вызванный метод определяет данные модели и возвращает в DispatcherServlet имя View.
- При помощи интерфейса ViewResolver DispatcherServlet определяет, какой view нужно использовать на основании полученного имени.
- После того, как View создан, DispatcherServlet отправляет данные модели в виде атрибутов в view, который в конечном итоге отображается в браузере.


**DispatcherServlet**:
- Обрабатывает все запросы и формирует ответы на них.
- Связывает между собой все элементы архитектуры Spring MVC.
- Обычный сервлет – конфигурируется в web.xml.

### 2. SPA особенности, плюсы и минусы

**Основные идеи:**
- Все веб приложение - единый веб документ
- Обновление документа при помощи AJAX
- Роутинг через Browser History API
- Клиент и сервер реализуются независимо, управляют своим состоянием независимо и взаимодействуют по REST.
- Формат передаваемых данных не специфицирован, но обычно это JSON.

**Преимущества**:
- Быстродействие, т. к. все необходимые ресурсы загружаются при первой загрузке страницы
- Оффлайн режим
- Независимая разработка фронта и бэка
- Улучшенная навигация
- Экономия трафика

**Недостатки**:
- Большинство контента загружается динамически через JS
- Следовательно, проблемы с SEO, аналитикой, security
- Следовательно, не работает при отключенном JS

### 3. 

## Билет 9

### 1. JNDI. JNDI в Java EE. Способы взаимодействия с JNDI. Их преимущества и недостатки.

Java Naming and Directory Interface (JNDI) — это набор Java API, организованный в виде службы
каталогов, который позволяет Java-клиентам открывать и
просматривать данные и объекты по их именам. 

В контексте Java EE, JNDI используется для поиска и управления ресурсами, такими как JDBC-источники данных, JMS (Java Message Service) соединения и EJB (Enterprise JavaBeans).


**JNDI в Java EE:**

1. **Локализация ресурсов**: JNDI позволяет приложениям находить данные и объекты через логические имена, а не через конкретные ссылки или пути. Это обеспечивает гибкость и упрощает управление ресурсами в распределенной среде.

2. **Интеграция с контейнером**: В Java EE контейнер предоставляет реализацию JNDI, позволяя приложениям легко находить и использовать ресурсы, которые контейнер управляет и конфигурирует.

**Два варианта использования JNDI:**
- CDI (аннотации) — работает только в managed компонентах. В Java EE JNDI часто используется в сочетании с внедрением зависимостей, позволяя автоматически вставлять ресурсы непосредственно в компоненты приложения. Аннотации CDI позволяют автоматизировать процесс поиска и инъекции ресурсов в управляемые компоненты (managed components), такие как EJB, сервлеты или JSF бины.
- Прямой вызов API — работает везде. В явном виде выполняется поиск и работа с ресурсами через JNDI API.

### 1. Прямой доступ к JNDI

Этот подход включает использование JNDI API для непосредственного поиска ресурсов.

#### Плюсы:
- **Гибкость**: Предоставляет полный контроль над тем, как и когда осуществляется доступ к ресурсам.
- **Универсальность**: Подходит для любых типов ресурсов, доступных через JNDI.

#### Минусы:
- **Сложность**: Требует написания дополнительного кода и обработки исключений.
- **Тесная связь с JNDI**: Код становится зависимым от JNDI, что может усложнить тестирование и миграцию.

### 2. Использование Resource Injection

Современные Java EE фреймворки (например, Spring) позволяют инжектировать ресурсы из JNDI напрямую в компоненты с использованием аннотаций.

#### Плюсы:
- **Простота и Читаемость**: Уменьшает количество шаблонного кода и упрощает его понимание.
- **Легкость Интеграции**: Хорошо интегрируется с фреймворками и контейнерами, упрощая конфигурацию и управление.

#### Минусы:
- **Зависимость от контейнера**: Требуется поддержка контейнера для инъекции ресурсов.
- **Меньший контроль**: Разработчики могут иметь меньше контроля над процессом поиска и получения ресурсов.

### 2. React - особенности, плюсы и минусы использования
React - js библиотека для построения UI. 

**Особенности**
- Компоненты и их переиспользование. Каждый компонент представляет собой независимый блок кода, который отвечает за определенную часть пользовательского интерфейса. 
- Декларативность
- JSX разметка: под капотом превращается в JS, компоненты должны возвращать всегда 1 элемент, все в camelCase, закрытые теги
- Легкая интеграция в существующие решения
- Можно писать нативные и фулстек приложения

React, популярная JavaScript библиотека для создания пользовательских интерфейсов, особенно веб-приложений, имеет свои плюсы и минусы. Понимание этих аспектов важно для принятия решения о том, подходит ли React для конкретного проекта.

### Плюсы React:

1. **Компонентный Подход**: React использует компонентный подход, который помогает в построении переиспользуемого и удобно поддерживаемого кода. Компоненты могут быть инкапсулированы, что облегчает управление состоянием и логикой.

2. **Виртуальный DOM**: React использует виртуальный DOM, что обеспечивает оптимизацию производительности. Изменения сначала применяются к виртуальному DOM, а затем, с помощью эффективного алгоритма сравнения, минимально необходимые изменения вносятся в реальный DOM.

3. **Широкое Сообщество и Экосистема**: Огромное сообщество разработчиков и множество доступных ресурсов, библиотек и инструментов.

4. **Гибкость и Интеграция**: React можно использовать в сочетании с различными архитектурами и библиотеками (например, с Redux для управления состоянием).

5. **Поддержка Одностраничных Приложений (SPA)**: React идеально подходит для создания быстрых и интерактивных одностраничных приложений.

### Минусы React:

2. **Только Библиотека, а Не Полноценный Фреймворк**: React отвечает только за слой представления (вид), в отличие от полноценных фреймворков типа Angular, которые предлагают более широкий набор инструментов "из коробки".

5. **Управление Состоянием**: Управление состоянием в крупных приложениях может стать сложным без использования дополнительных библиотек, таких как Redux.

6. **SEO Оптимизация**: Для одностраничных приложений на React может потребоваться дополнительная работа для оптимизации под поисковые системы

### 3.

## Билет 10

### 1. Профили платформы Java/Jakarta EE.

Java EE представляет собой набор спецификаций, предназначенных для разработки масштабируемых, многоуровневых, надежных и безопасных сетевых приложений. В рамках Java EE существуют различные профили, каждый из которых предназначен для определенных целей и задач

### Основные Профили Java EE:

1. **Full Profile**: 
   - **Описание**: Полная платформа Java EE включает в себя все спецификации Java EE, предоставляя полный набор возможностей для создания корпоративных приложений.
   - **Ключевые Технологии**: EJB (Enterprise JavaBeans), JPA (Java Persistence API), JMS (Java Message Service), JAX-RS (Java API for RESTful Web Services), JAX-WS (Java API for XML-Based Web Services), JSF (JavaServer Faces) и другие.
   - **Использование**: Идеально подходит для крупных, многоуровневых корпоративных приложений, требующих широкой функциональности и интеграции различных компонентов.

2. **Web Profile**: 
   - **Описание**: Профиль Web представляет собой упрощенный набор спецификаций, ориентированный на веб-приложения. Он включает основные технологии, необходимые для разработки веб-приложений, без более сложных и тяжеловесных компонентов, характерных для полной платформы.
   - **Ключевые Технологии**: Servlets, JSP (JavaServer Pages), JSF, JPA, JTA (Java Transaction API), CDI (Contexts and Dependency Injection), Bean Validation.
   - **Использование**: Подходит для разработки веб-приложений, где не требуется полный набор спецификаций Java EE.
  

### 2. Способы реализации DI в Spring. @Qualifier.

**Через конструктор:**

Просто передаем бин конструктору. Если несколько конструкторов, то нужно указать @Autowired к какому-то конструктору, чтобы Спринг знал, какой использовать для внедрения зависимостей. Рекомендуется для внедрения обязательных зависимостей.

**Через сеттер:**
Спринг вызовет этот метод для внедрения зависимостей. Рекомендуется использовать для внедрения опциональных зависимостей.

**Через поле:**
Спринг просто внедрит зависимость в это поле. Часто используется из-за своей простоты и удобства, так как не требует написания дополнительного кода. Не рекомендуется использовать Field Injection для обязательных зависимостей из-за сложности в тестировании и потенциальных проблем с порядком инициализации. Также не может использоваться для присвоения зависимостей final полям.


Аннотация @Qualifier в Spring Framework используется для уточнения выбора бина при внедрении зависимостей, когда в контексте приложения существует более одного бина одного и того же типа. Это позволяет более точно указать, какой именно бин должен быть внедрен, предотвращая возможные конфликты и ошибки.

Можно определить квалификаторы, аннотируя бины с @Qualifier и указывая уникальное имя. Это имя затем используется для идентификации нужного бина при внедрении зависимостей.

```java
Copy code
@Component
@Qualifier("mainDataService")
public class MainDataService implements DataService {
    // ...
}

@Component
@Qualifier("secondaryDataService")
public class SecondaryDataService implements DataService {
    // ...
}
```

### 3. 


## Билет 11

### 1. Построение пользовательского интерфейса в JSF. Иерархия компонентов JSF

Интерфейс строится из компонентов. 
- Компоненты расположены на Facelets-шаблонах или страницах JSP. 
- Компоненты реализуют интерфейс javax.faces.component.UIComponent. 
- Можно создавать собственные компоненты.
- Компоненты на странице объединены в древовидную структуру — представление. 
- Корневым элементов представления является экземпляр класса javax.faces.component.UIViewRoot.

Сам шаблон интерфейса располагается на Facelets и состоит из комбинации различных тегов. Можно создавать свои компоненты отнаследовав их от необходимого класса/интерфейса и встраивать в facelets

### 2. CDI Beans: принципы инъекции. Способы разрешения ситуации неоднозначных зависимостей (2 бина реализуют 1 интерфейс)

CDI (Contexts and Dependency Injection) в Java EE и Jakarta EE предоставляет мощные возможности для управления зависимостями и жизненным циклом бинов. Основной принцип инъекции заключается в автоматическом управлении зависимостями между компонентами, что упрощает разработку и поддержку приложений.

### Принципы Инъекции в CDI

1. **Автоматическое Внедрение**: CDI контейнер автоматически внедряет зависимости в бины через конструкторы, сеттеры или поля.
2. **Типобезопасность**: CDI обеспечивает типобезопасность при внедрении, что снижает риск ошибок во время выполнения.
3. **Контекстная Зависимость**: Бины могут быть связаны с определенными контекстами (например, запросом, сессией), что позволяет управлять их жизненным циклом.

### Разрешение Неоднозначных Зависимостей

Когда два или более бина реализуют один интерфейс, возникает неоднозначность зависимостей. Для разрешения этой ситуации в CDI есть несколько способов:

1. **Аннотация @Default**: Используется по умолчанию, когда не указано другое квалификационное имя. Если один из бинов отмечен как `@Default`, CDI будет использовать его, когда точный квалификатор не указан.

2. **Создание Собственных Квалификаторов**:
   - Определите собственный квалификатор с аннотацией `@Qualifier`.
   - Примените этот квалификатор к нужному бину.
   - Укажите тот же квалификатор при внедрении зависимости.

   ```java
   @Qualifier
   @Retention(RUNTIME)
   @Target({METHOD, FIELD, PARAMETER, TYPE})
   public @interface MyQualifier {}

   @MyQualifier
   public class MyBeanImpl implements MyInterface {}

   @Inject
   @MyQualifier
   private MyInterface myBean;
   ```

3. **Аннотация @Alternative**:
   - Отметьте один из бинов как `@Alternative`.
   - Активируйте этот альтернативный бин в файле `beans.xml`.

   ```java
   @Alternative
   public class AlternativeBeanImpl implements MyInterface {}

   <!-- В beans.xml -->
   <beans>
       <alternatives>
           <class>com.example.AlternativeBeanImpl</class>
       </alternatives>
   </beans>
   ```

4. **Использование @Named**:
   - Используйте аннотацию `@Named` для присвоения бинам уникальных имен.
   - Внедрите зависимость, указав имя с помощью аннотации `@Inject`.

   ```java
   @Named("myNamedBean")
   public class MyBeanImpl implements MyInterface {}

   @Inject
   @Named("myNamedBean")
   private MyInterface myBean;
   ```

### 3.

## Билет 12

### 1. Ангуляр: шаблоны, представление

**Шаблоны (Templates)**
Шаблоны в Angular - это HTML-представления, которые используют Angular-расширения. Они могут включать директивы, привязки данных и другие конструкции Angular.

- Директивы: Указания Angular о том, как должен работать DOM при изменении данных. По своей реализации директивы практически идентичны компонентам (компонент — это директива с HTML-шаблоном). Есть два вида директив: структурные (добавляют, удаляют или заменяют элементы в DOM. Примеры: *ngIf, *ngFor) и атрибуты (задают элементу другое поведение. Примеры: [ngStyle], [ngClass]).
- Привязка данных: Механизмы, позволяющие связывать свойства в классе компонента с элементами в шаблоне. Существует несколько форм привязки данных:
  - Интерполяция: {{ value }}
  - Свойство: [property]="value"
  - Событие: (event)="handler()"
  - Двусторонняя: [(ngModel)]="value"
> Подробнее про привязку в одном из предыдущих вопросов
- Пайпы (Pipes): Позволяют осуществлять преобразование формата отображаемых данных (например, дат или денежных сумм) прямо в шаблоне. Например, {{ date | date:'shortDate' }} преобразует объект Date в короткую дату. Фильтры можно объединять в последовательности (pipe chains). 


**Представления (Views)**
Представления - это то, что создается на основе шаблонов и модели данных компонента при рендеринге компонента. 
- Компоненты и их шаблоны формируют представления
- Компонент может содержать *иерархию представлений*, которая содержит *встроенные представления* из других компонентов
- Каждый компонент содержит *корневое представление* (host view)

### 2. Спринг Бут, зачем он нужен. Стартеры
