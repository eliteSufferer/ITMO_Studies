## Билет 1

### 1. CDI бины, именование CDI бинов, @Alternative

**CDI Beans**
- Универсальные компоненты уровня бизнес-логики.
- Абстрактная реализация паттерна CDI в Java / Jakarta EE.
- «Клонируют» основные концепции бинов из Spring.
- Общая идея – «отвязаться» от конкретного фреймворка при создании бизнес-логики внутри приложения.
- Конфигурируются аннотациями, основной пакет – javax.enterprise.context.
- Для CDI используется универсальная аннотация @Inject.
- В отличие от EJB, не обеспечивают горизонтальную масштабируемость «сами по себе»
- Разные контексты (мб перчислить)

**Именование бинов**
1. Неявное Именование: По умолчанию, CDI автоматически присваивает имя бину, основываясь на имени класса с первой буквой в нижнем регистре. Например, класс PaymentService будет иметь имя бина paymentService.
2. Явное Именование с @Named: Если вам нужно использовать конкретное имя для бина, можно использовать аннотацию @Named, чтобы указать это имя. Это полезно для доступа к бинам в EL-выражениях (Expression Language) в JSF и других технологиях.


**@Alternative**
Аннотация @Alternative позволяет определить дополнительные реализации для бина, которые могут быть выбраны вместо стандартной реализации. Для активации альтернативного бина его нужно указать в файле конфигурации beans.xml. Это особенно полезно в ситуациях, когда есть несколько реализаций одного и того же интерфейса, и надо явно выбрать, какая реализация должна использоваться в определенном контексте приложения.

### 2. DI в Angular
**Dependency injection**
- Общая концепция: зависимости объекта передаются ему извне, а не создаются самим объектом
- Компоненты могут использовать сервисы с помощью DI.
- Для того, чтобы класс можно было использовать с помощью DI, он должен
содержать декоратор @Injectable()

**Основные принципы реализации DI**
- Приложение содержит как минимум один глобальный Injector, который
занимается DI.
- Injector создаёт зависимости и передаёт их экземпляры контейнеру
- Провайдер (provider) -- это объект, который сообщает Injector’у, как
получить или создать экземпляр зависимости.
- Обычно провайдером сервиса является сам его класс. Для каждого сервиса должен быть зарегистрирован как минимум один провайдер.
- Зависимости компонентов указываются в качестве параметров их конструкторов

### 3. Конфигурация Spring Web MVC без использования Spring Boot. Написать web.xml для приложения развернутого на сервере приложений Jakarta EE

## Билет 2

### 1. Location Transparency. Реализация в Java/Java EE

Location Transparency описывает концепцию, согласно которой клиентский код может вызывать методы на объекте (или сервисе) без знания физического местоположения этого объекта. Благодаря CDI не важно, где физически
расположен вызываемый компонент — за его
вызов отвечает контейнер.

В Java и Java EE, Location Transparency традиционно достигается с использованием нескольких технологий:

1. **RMI (Remote Method Invocation)**: Это базовая технология Java для взаимодействия между приложениями в сети. RMI позволяет объектам, расположенным на разных JVM, взаимодействовать друг с другом так, как будто они находятся в одной JVM.

2. **EJB (Enterprise JavaBeans)**: В рамках Java EE, EJB обеспечивает более высокоуровневый способ достижения прозрачности расположения. Stateful, Stateless и Singleton session beans могут быть доступны для клиентских приложений без информации о их физическом расположении.

3. **JNDI (Java Naming and Directory Interface)**: Используется для поиска EJB и других ресурсов в сети. Клиенты ищут сервисы по логическому имени, и JNDI обеспечивает связь с физическим расположением или конкретной реализацией сервиса.

4. **Web Services (SOAP and REST)**: Они обеспечивают еще один уровень прозрачности расположения, позволяя клиентам обращаться к сервисам через HTTP, не заботясь о деталях их реализации.

### 2. Реализация уровня представления в Spring Web MVC


### 3. Напишите реакт компонент реализующий карусель изображений поле каруселью подразумевается , отображается одно изображение из н, можно переключать кнопками вперёд и назад пролистывая изображения, хранятся на клиентском устройстве, список путей к файлам передавать через props

## Билет 3

### 1. RMI. Реализация RMI в Java EE



## Билет 4

### 1. Управляемые бины - назначение, способы конфигурации, доступ из jsp/xhtml

**Назначение**
- Содержат параметры и методы для обработки данных с компонентов.
- Используются для обработки событий UI и валидации
данных.
- Жизненным циклом управляет JSF Runtime
Envronment.
- Есть разные контексты (Request, Session, Application...)
- Доступ из JSF-страниц осуществляется с помощью
элементов EL.
- Конфигурация задаётся в faces-config.xml (JSF 1.X),
либо с помощью аннотаций (JSF 2.0).
- Вместо них могут использоваться CDI-бины, EJB или
бины Spring.

**Конфигурация**

1. Способ 1 — через faces-config.xml:

```xml
<managed-bean>
<managed-bean-name>customer</managed-bean-name>
<managed-bean-class>CustomerBean</managed-bean-class>
<managed-bean-scope>request</managed-bean-scope>
<managed-property>
<property-name>areaCode</property-name>
<value>#{initParam.defaultAreaCode}</value>
</managed-property>
</managed-bean>
```

2. Способ 2 (JSF 2.0) — с помощью аннотаций:

```java
@ManagedBean(name="customer")
@RequestScoped
public class CustomerBean {
...
@ManagedProperty(value="#{initParam.defaultAreaCode}"
name="areaCode")
private String areaCode;
...
}
```

**Использование**

Доступ к управляемым бинам со страниц приложения осуществляется с помощью EL-выражений:

```xhtml
...
<h:inputText value="#{user.name}"
validator="#{user.validate}" />
...
<h:inputText binding="#{user.nameField}" />
...
<h:commandButton action="#{user.save}"
value="Save" />
...
```

### 2. Архитектура и состав Spring Web MVC
Spring Web MVC – “базовый” фреймворк в составе Spring для разработки веб-приложений, основан на паттерне MVC; универсальный, удобен для
разработки REST API.

**Архитекутра**

![image](https://github.com/eliteSufferer/ITMO_Studies/assets/46615564/84e164fc-ca6d-4a07-bf9c-aa26a77a5c5e)

1. **HTTP Request**: Все начинается с HTTP-запроса, который отправляется на сервер.

2. **DispatcherServlet**:
   - Обрабатывает все запросы и формирует ответы на них.
   - Связывает между собой все элементы архитектуры Spring MVC.
   - Обычный сервлет – конфигурируется в web.xml.

3. **Handler Mapping (1)**:
   - Интерфейс, позволяющий распределять запросы по различным обработчикам (контроллерам).
   - Помимо «основного» Handler'а, в обработке
запроса могут участвовать один или несколько
«перехватчиков» (реализаций интерфейса HandlerInterceptor).
  - Механизм в общем похож на сервлеты и
фильтры.

4. **Controller (2)**:
   - Контроллер берет на себя обработку запроса после того, как `Handler Mapping` определяет, что он должен этим заниматься.
   - Здесь выполняется бизнес-логика, обработка данных из запроса, взаимодействие с Model (сервисы, компоненты доступа к данным и т.д.) и возвращается некоторый результат, обычно в виде имени представления и модели данных для этого представления (объект `ModelAndView`).

5. **View Resolver (3)**:
   - Представление в Spring Web MVC может быть построено
на разных технологиях, с каждым представлением сопоставляется его
символическое имя.
   - Преобразованием символических имён в ссылки на
конкретные представления занимается специальный
класс, реализующий интерфейс
org.springframework.web.servlet.ViewResolver.
   - В одном приложении можно использовать несколько
ViewResolver'ов.
   - После того, как контроллер выполнит свою работу, `View Resolver` определяет, какое представление должно быть использовано для отображения результатов выполнения.
   - Он преобразует логическое имя представления, предоставленное контроллером, в фактический путь к файлу представления (например, к файлу JSP).

1. **View (4)**:
   - Представление отвечает за отображение ответа пользователю. Это может быть страница JSP, HTML и т.д., которая рендерит данные, предоставленные контроллером.
   - После рендеринга представление (View) возвращается обратно в `DispatcherServlet`.

2. **HTTP Response**:
   - Наконец, `DispatcherServlet` отправляет сформированный ответ обратно клиенту.

Эта схема демонстрирует, как Spring MVC следует паттерну "Front Controller", где `DispatcherServlet` играет центральную роль в координации процесса обработки запроса, взаимодействия с компонентами бизнес-логики и подготовке ответа для клиента.
**Состав приложения**

- Model:
  - Хранит данные, необходимые для
    формирования представления.
  - Сами по себе эти данные – обычные POJO.
  - В общем случае, реализует интерфейс
    org.springframework.ui.Model.
  - Есть «упрощённая» реализация,
    представляющая из себя Map - org.springframework.ui.ModelMap.
- View – отвечает за отображение данных модели.
  - Фреймворк не специфицирует жёстко
  технологию, на которой должно быть построено
  представление.
  - Вариант «по-умолчанию» – JSP.
  - Можно использовать Thymeleaf, FreeMarker, etc.
  - Можно реализовать представление вне
  контекста Spring – целиком на JS.
- Controller – обрабатывает запрос пользователя,
создаёт соответствующую модель и передаёт её
для отображения в представление.
  - Класс, который связывает модель с
представлением, управляет состоянием модели.
  - Помечается аннотацией @Controller.
  - Класс или его методы могут быть помечены
  аннотациями, «привязывающими» их к
  определённым методам HTTP или URL.

### 3. Интерфейс на angular, проверяющий, аутентифицирован ли пользователь(по наличию куки jsessionid), и, если нет, позволяющий ему аутентифицировться посредством ввода логина и пароля.

```ts
import { Component } from '@angular/core';
import { CookieService } from 'ngx-cookie-service';

@Component({
  selector: 'app-auth',
  template: `
    <div *ngIf="!isAuthenticated">
      <form (ngSubmit)="login()">
        <input type="text" [(ngModel)]="username" name="username" placeholder="Username">
        <input type="password" [(ngModel)]="password" name="password" placeholder="Password">
        <button type="submit">Login</button>
      </form>
    </div>
    <div *ngIf="isAuthenticated">
      <p>User is authenticated</p>
      <!-- Другие элементы пользовательского интерфейса для аутентифицированного пользователя -->
    </div>
  `
})
export class AuthComponent {
  isAuthenticated = false;
  username: string;
  password: string;

  constructor(private cookieService: CookieService) {}

  ngOnInit() {
    this.isAuthenticated = this.cookieService.check('JSESSIONID');
  }

  login() {
    // Здесь должна быть логика аутентификации
    // Например, отправка данных на сервер и установка куки JSESSIONID при успешном входе
  }
}
```


