## Билет 1

### 1. CDI бины, именование CDI бинов, @Alternative

**CDI Beans**
- Универсальные компоненты уровня бизнес-логики.
- Абстрактная реализация паттерна CDI в Java / Jakarta EE.
- «Клонируют» основные концепции бинов из Spring.
- Общая идея – «отвязаться» от конкретного фреймворка при создании бизнес-логики внутри приложения.
- Конфигурируются аннотациями, основной пакет – javax.enterprise.context.
- Для CDI используется универсальная аннотация @Inject.
- В отличие от EJB, не обеспечивают горизонтальную масштабируемость «сами по себе»
- Разные контексты (мб перчислить)

**Именование бинов**

1. Неявное Именование: По умолчанию, CDI автоматически присваивает имя бину, основываясь на имени класса с первой буквой в нижнем регистре. Например, класс PaymentService будет иметь имя бина paymentService.
2. Явное Именование с @Named: Если вам нужно использовать конкретное имя для бина, можно использовать аннотацию @Named, чтобы указать это имя. Это полезно для доступа к бинам в EL-выражениях (Expression Language) в JSF и других технологиях.


**@Alternative**

Аннотация @Alternative позволяет определить дополнительные реализации для бина, которые могут быть выбраны вместо стандартной реализации. Для активации альтернативного бина его нужно указать в файле конфигурации beans.xml. Это особенно полезно в ситуациях, когда есть несколько реализаций одного и того же интерфейса, и надо явно выбрать, какая реализация должна использоваться в определенном контексте приложения.

### 2. DI в Angular
**Dependency injection**
- Общая концепция: зависимости объекта передаются ему извне, а не создаются самим объектом
- Компоненты могут использовать сервисы с помощью DI.
- Для того, чтобы класс можно было использовать с помощью DI, он должен
содержать декоратор @Injectable()

**Основные принципы реализации DI**
- Приложение содержит как минимум один глобальный Injector, который
занимается DI.
- Injector создаёт зависимости и передаёт их экземпляры контейнеру
- Провайдер (provider) -- это объект, который сообщает Injector’у, как
получить или создать экземпляр зависимости.
- Обычно провайдером сервиса является сам его класс. Для каждого сервиса должен быть зарегистрирован как минимум один провайдер.
- Зависимости компонентов указываются в качестве параметров их конструкторов

### 3. Конфигурация Spring Web MVC без использования Spring Boot. Написать web.xml для приложения развернутого на сервере приложений Jakarta EE

```xml
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
                             http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">

    <!-- Настройка DispatcherServlet -->
    <servlet>
        <servlet-name>dispatcher</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>/WEB-INF/spring-dispatcher-servlet.xml</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
    </servlet>

    <servlet-mapping>
        <servlet-name>dispatcher</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>

    <!-- Другие конфигурации -->

</web-app>
```

Еще можно сделать `<filter>` или `error-page`

## Билет 2

### 1. Location Transparency. Реализация в Java/Java EE

Location Transparency описывает концепцию, согласно которой клиентский код может вызывать методы на объекте (или сервисе) без знания физического местоположения этого объекта. Благодаря CDI не важно, где физически
расположен вызываемый компонент — за его
вызов отвечает контейнер.

В Java и Java EE, Location Transparency традиционно достигается с использованием нескольких технологий:

1. **RMI (Remote Method Invocation)**: Это базовая технология Java для взаимодействия между приложениями в сети. RMI позволяет объектам, расположенным на разных JVM, взаимодействовать друг с другом так, как будто они находятся в одной JVM.

2. **EJB (Enterprise JavaBeans)**: В рамках Java EE, EJB обеспечивает более высокоуровневый способ достижения прозрачности расположения. Stateful, Stateless и Singleton session beans могут быть доступны для клиентских приложений без информации о их физическом расположении.

3. **JNDI (Java Naming and Directory Interface)**: Используется для поиска EJB и других ресурсов в сети. Клиенты ищут сервисы по логическому имени, и JNDI обеспечивает связь с физическим расположением или конкретной реализацией сервиса.

4. **Web Services (SOAP and REST)**: Они обеспечивают еще один уровень прозрачности расположения, позволяя клиентам обращаться к сервисам через HTTP, не заботясь о деталях их реализации.

### 2. Реализация уровня представления в Spring Web MVC

Spring Web MVC — это часть Spring Framework, предоставляющая мощные средства для создания веб-приложений на основе модели Model-View-Controller (MVC). В рамках этой модели уровень представления отвечает за отображение данных, предоставленных моделью, в формате, понятном для пользователя. Вот основные аспекты реализации уровня представления в Spring Web MVC:

### 1. Контроллеры

Контроллеры в Spring MVC обрабатывают входящие HTTP-запросы, выполняют бизнес-логику и возвращают модель данных вместе с именем представления для отображения. Они аннотированы с `@Controller` и используют аннотации, такие как `@RequestMapping`, для определения обработчиков запросов.

### 2. ViewResolver

`ViewResolver` в Spring MVC определяет, какое представление должно быть использовано для отображения данных. Он преобразует строковое имя представления, возвращенное контроллером, в фактический объект `View`. Spring Boot автоматически конфигурирует `ViewResolver`, но вы также можете настроить его вручную.

### 3. Представления

Представления в Spring MVC отвечают за отображение данных, предоставленных контроллерами. Это может быть JSP, Thymeleaf, FreeMarker или другие технологии шаблонов.

- **JSP**: Традиционный выбор для представлений в Java-веб-приложениях.
- **Thymeleaf**: Современный серверный Java-шаблонизатор для веб-приложений.
- **FreeMarker**: Еще одна популярная библиотека шаблонов.

### 4. Передача данных в представления

Данные передаются в представления через модель. В Spring MVC это обычно делается с помощью объекта `Model`, который передается в метод контроллера.

```java
public String hello(Model model) {
    model.addAttribute("message", "Hello Spring MVC");
    return "helloView";
}
```


### 3. Напишите реакт компонент реализующий карусель изображений поле каруселью подразумевается , отображается одно изображение из н, можно переключать кнопками вперёд и назад пролистывая изображения, хранятся на клиентском устройстве, список путей к файлам передавать через props

```jsx
const ImageCarousel = ({ imagePaths }) => {
  const [currentImageIndex, setCurrentImageIndex] = useState(0);

  const goToNext = () => {
    setCurrentImageIndex((prevIndex) =>
      prevIndex === imagePaths.length - 1 ? 0 : prevIndex + 1
    );
  };

  const goToPrev = () => {
    setCurrentImageIndex((prevIndex) =>
      prevIndex === 0 ? imagePaths.length - 1 : prevIndex - 1
    );
  };

  return (
    <div>
      <img src={imagePaths[currentImageIndex]} alt={`Slide ${currentImageIndex}`} />
      <button onClick={goToPrev}>Prev</button>
      <button onClick={goToNext}>Next</button>
    </div>
  );
};

export default ImageCarousel;
```

Использование:

```jsx
const App = () => {
  const images = [
    'path/to/your/image1.jpg',
    'path/to/your/image2.jpg',
    'path/to/your/image3.jpg',
    // Другие пути к изображениям
  ];

  return (
    <div>
      <ImageCarousel imagePaths={images} />
    </div>
  );
};

export default App;
```

## Билет 3

### 1. RMI. Реализация RMI в Java EE



## Билет 4

### 1. Управляемые бины - назначение, способы конфигурации, доступ из jsp/xhtml

**Назначение**
- Содержат параметры и методы для обработки данных с компонентов.
- Используются для обработки событий UI и валидации
данных.
- Жизненным циклом управляет JSF Runtime
Envronment.
- Есть разные контексты (Request, Session, Application...)
- Доступ из JSF-страниц осуществляется с помощью
элементов EL.
- Конфигурация задаётся в faces-config.xml (JSF 1.X),
либо с помощью аннотаций (JSF 2.0).
- Вместо них могут использоваться CDI-бины, EJB или
бины Spring.

**Конфигурация**

1. Способ 1 — через faces-config.xml:

```xml
<managed-bean>
<managed-bean-name>customer</managed-bean-name>
<managed-bean-class>CustomerBean</managed-bean-class>
<managed-bean-scope>request</managed-bean-scope>
<managed-property>
<property-name>areaCode</property-name>
<value>#{initParam.defaultAreaCode}</value>
</managed-property>
</managed-bean>
```

2. Способ 2 (JSF 2.0) — с помощью аннотаций:

```java
@ManagedBean(name="customer")
@RequestScoped
public class CustomerBean {
...
@ManagedProperty(value="#{initParam.defaultAreaCode}"
name="areaCode")
private String areaCode;
...
}
```

**Использование**

Доступ к управляемым бинам со страниц приложения осуществляется с помощью EL-выражений:

```xhtml
...
<h:inputText value="#{user.name}"
validator="#{user.validate}" />
...
<h:inputText binding="#{user.nameField}" />
...
<h:commandButton action="#{user.save}"
value="Save" />
...
```

### 2. Архитектура и состав Spring Web MVC
Spring Web MVC – “базовый” фреймворк в составе Spring для разработки веб-приложений, основан на паттерне MVC; универсальный, удобен для
разработки REST API.

**Архитекутра**

![image](https://github.com/eliteSufferer/ITMO_Studies/assets/46615564/84e164fc-ca6d-4a07-bf9c-aa26a77a5c5e)

1. **HTTP Request**: Все начинается с HTTP-запроса, который отправляется на сервер.

2. **DispatcherServlet**:
   - Обрабатывает все запросы и формирует ответы на них.
   - Связывает между собой все элементы архитектуры Spring MVC.
   - Обычный сервлет – конфигурируется в web.xml.

3. **Handler Mapping (1)**:
   - Интерфейс, позволяющий распределять запросы по различным обработчикам (контроллерам).
   - Помимо «основного» Handler'а, в обработке
запроса могут участвовать один или несколько
«перехватчиков» (реализаций интерфейса HandlerInterceptor).
  - Механизм в общем похож на сервлеты и
фильтры.

4. **Controller (2)**:
   - Контроллер берет на себя обработку запроса после того, как `Handler Mapping` определяет, что он должен этим заниматься.
   - Здесь выполняется бизнес-логика, обработка данных из запроса, взаимодействие с Model (сервисы, компоненты доступа к данным и т.д.) и возвращается некоторый результат, обычно в виде имени представления и модели данных для этого представления (объект `ModelAndView`).

5. **View Resolver (3)**:
   - Представление в Spring Web MVC может быть построено
на разных технологиях, с каждым представлением сопоставляется его
символическое имя.
   - Преобразованием символических имён в ссылки на
конкретные представления занимается специальный
класс, реализующий интерфейс
org.springframework.web.servlet.ViewResolver.
   - В одном приложении можно использовать несколько
ViewResolver'ов.
   - После того, как контроллер выполнит свою работу, `View Resolver` определяет, какое представление должно быть использовано для отображения результатов выполнения.
   - Он преобразует логическое имя представления, предоставленное контроллером, в фактический путь к файлу представления (например, к файлу JSP).

1. **View (4)**:
   - Представление отвечает за отображение ответа пользователю. Это может быть страница JSP, HTML и т.д., которая рендерит данные, предоставленные контроллером.
   - После рендеринга представление (View) возвращается обратно в `DispatcherServlet`.

2. **HTTP Response**:
   - Наконец, `DispatcherServlet` отправляет сформированный ответ обратно клиенту.

Эта схема демонстрирует, как Spring MVC следует паттерну "Front Controller", где `DispatcherServlet` играет центральную роль в координации процесса обработки запроса, взаимодействия с компонентами бизнес-логики и подготовке ответа для клиента.
**Состав приложения**

- Model:
  - Хранит данные, необходимые для
    формирования представления.
  - Сами по себе эти данные – обычные POJO.
  - В общем случае, реализует интерфейс
    org.springframework.ui.Model.
  - Есть «упрощённая» реализация,
    представляющая из себя Map - org.springframework.ui.ModelMap.
- View – отвечает за отображение данных модели.
  - Фреймворк не специфицирует жёстко
  технологию, на которой должно быть построено
  представление.
  - Вариант «по-умолчанию» – JSP.
  - Можно использовать Thymeleaf, FreeMarker, etc.
  - Можно реализовать представление вне
  контекста Spring – целиком на JS.
- Controller – обрабатывает запрос пользователя,
создаёт соответствующую модель и передаёт её
для отображения в представление.
  - Класс, который связывает модель с
представлением, управляет состоянием модели.
  - Помечается аннотацией @Controller.
  - Класс или его методы могут быть помечены
  аннотациями, «привязывающими» их к
  определённым методам HTTP или URL.

### 3. Интерфейс на angular, проверяющий, аутентифицирован ли пользователь(по наличию куки jsessionid), и, если нет, позволяющий ему аутентифицировться посредством ввода логина и пароля.

```ts
import { Component } from '@angular/core';
import { CookieService } from 'ngx-cookie-service';

@Component({
  selector: 'app-auth',
  template: `
    <div *ngIf="!isAuthenticated">
      <form (ngSubmit)="login()">
        <input type="text" [(ngModel)]="username" name="username" placeholder="Username">
        <input type="password" [(ngModel)]="password" name="password" placeholder="Password">
        <button type="submit">Login</button>
      </form>
    </div>
    <div *ngIf="isAuthenticated">
      <p>User is authenticated</p>
      <!-- Другие элементы пользовательского интерфейса для аутентифицированного пользователя -->
    </div>
  `
})
export class AuthComponent {
  isAuthenticated = false;
  username: string;
  password: string;

  constructor(private cookieService: CookieService) {}

  ngOnInit() {
    this.isAuthenticated = this.cookieService.check('JSESSIONID');
  }

  login() {
    // Здесь должна быть логика аутентификации
    // Например, отправка данных на сервер и установка куки JSESSIONID при успешном входе
  }
}
```

## Билет 5

### 1. Области видимости MB. Способы задания области видимости

**Сопособы конфигурации**: Задаётся через faces-config.xml или с помощью аннотаций.


Пример через faces-config:
```xml
<managed-bean>
<managed-bean-name>customer</managed-bean-name>
<managed-bean-class>CustomerBean</managed-bean-class>
<managed-bean-scope>request</managed-bean-scope>
...
```

Через аннотации:
```java
@ManagedBean(name="customer")
@RequestScoped
public class CustomerBean {
...
}
```

6 вариантов конфигурации:
- @NoneScoped — контекст не определён, жизненным
циклом управляют другие бины.
- @RequestScoped (применяется по умолчанию) — Бин создается заново при каждом HTTP запросе, используется для коротких операций, не требующих сохранения состояния между запросами.
- @ViewScoped (JSF 2.0) — Бин остается активным в течение жизни одного и того же JSF view (например, пока пользователь находится на одной и той же странице). Используется для операций, состояние которых должно сохраняться при AJAX-запросах на одной странице.
- @SessionScoped — Бин остается активным в течение всей пользовательской сессии. Используется для данных, которые должны сохраняться между различными запросами в рамках одной сессии пользователя.
- @ApplicationScoped — Бин остается активным в течение всего времени жизни приложения. Используется для данных, общих для всех пользователей приложения.
- @CustomScoped (JSF 2.0) — бин сохраняется в Map; программист сам управляет его жизненным циклом.

### 2. Принципиальные различия spring и java EE

Spring Framework и Java/Jakarta EE представляют собой две популярные платформы для разработки предприятия в экосистеме Java. Обе платформы обеспечивают обширный набор функций для создания масштабируемых и гибких приложений, но имеют ряд принципиальных отличий в подходах к реализации и архитектуре.

### Идейные отличия:
- «Базовая» концепция Java EE – разделение
обязанностей между контейнером и
компонентом; «базовая» концепция Spring – IoC /
CDI.
- Контейнер в Java EE включает в себя
приложение; приложение в Spring включает в
себя контейнер.
- Java EE – спецификация; Spring – фреймворк.

### 1. Подход к Конфигурации

- **Spring**: Использует подход "конфигурация через код" (JavaConfig), позволяя разработчикам определять бины и конфигурации непосредственно в Java-коде. Поддерживает также декларативную конфигурацию через XML и аннотации. Spring Boot дополнительно предоставляет автоматическую конфигурацию на основе классов, доступных в classpath.
- **Java/Jakarta EE**: Традиционно использовал декларативный подход с помощью XML-файлов, но современные версии Jakarta EE также широко используют аннотации и CDI (Contexts and Dependency Injection) для упрощения конфигурации.

### 2. Внедрение Зависимостей (Dependency Injection)

- **Spring**: Одна из ключевых особенностей Spring - это мощная поддержка внедрения зависимостей через аннотации (`@Autowired`) и конструкторы. Spring Boot упрощает этот процесс еще больше.
- **Java/Jakarta EE**: CDI является стандартом для внедрения зависимостей в Java EE. Он также использует аннотации (например, `@Inject`) и обеспечивает тесную интеграцию с другими компонентами Java EE.

### 3. Стандарты и Портативность

- **Spring**: Хотя Spring использует некоторые стандарты Java EE, такие как JPA для работы с базами данных, он сам по себе не является стандартом и работает как самостоятельный фреймворк.
- **Java/Jakarta EE**: Полностью основан на стандартах, что обеспечивает высокий уровень портативности между различными реализациями и серверами приложений.

### 4. Модель Программирования

- **Spring**: Предоставляет более гибкую и легкую модель программирования, что делает его популярным выбором для создания микросервисов и облачных приложений.
- **Java/Jakarta EE**: Следует более формальному подходу, основанному на стандартах, что может быть предпочтительнее в больших и строго стандартизированных корпоративных средах.


### 3. Компонент для React, формирующий строку с автодополнением. Массив значений для автодополнения должен получаться с сервера посредством запроса к REST API

```jsx
function AutoCompleteComponent() {
  const [data, setData] = useState([]);
  const [input, setInput] = useState('');
  const [suggestions, setSuggestions] = useState([]);

  useEffect(() => {
    fetch(`http://example.com/api/data`)
      .then(response => response.json())
      .then(data => setData(data))
      .catch(error => console.error(error));
  }, []);

  const handleChange = (text) => {
    setInput(text);
    let finalSuggestions = [];
    if (text.length > 0) {
      finalSuggestions = data.filter(dat => dat.toLowerCase().startsWith(text.toLowerCase()));
    }
    setSuggestions(finalSuggestions);
  };

  return (
    <div>
      <input type="text" value={input} onChange={(e) => handleChange(e.target.value)} />
      {suggestions.map((text, index) => (
        <span key={index}>{text}</span>
      ))}
    </div>
  );
}
```

## Билет 6

### 1. Фазы Invoke Application и Render Response

Эти две фазы идут после фазы обновления значений компонентов.

**Invoke Application:**

На этом этапе реализация JavaServer Faces обрабатывает все события на уровне приложения, такие как отправка формы или переход на другую страницу.

**Render Response:**
- JSF Runtime обновляет представление в соответствии с результатами обработки запроса.
- Если это первый запрос к странице, то компоненты помещаются в иерархию представления.
- Формируется ответ сервера на запрос.
- На стороне клиента происходит обновление страницы.

### 2. Какие задачи выполняет Spring Boot

Spring Boot — это часть большой экосистемы Spring, предназначенная для упрощения процесса разработки и развертывания приложений на основе Spring Framework. Основные задачи и особенности Spring Boot включают:

1. **Автоконфигурация**: Spring Boot автоматически настраивает ваше приложение на основе добавленных зависимостей, что снижает необходимость в явной конфигурации. Предоставляет «типовую» конфигурацию компонентов на основе автоконфигураций;

2. **Встроенный сервер**: Позволяет запускать веб-приложения без необходимости развертывания на внешних серверах приложений. Spring Boot поддерживает встроенные серверы, такие как Tomcat, Jetty и Undertow.

3. **Управление зависимостями**: Spring Boot упрощает управление зависимостями, предоставляя готовые "стартеры", которые объединяют зависимости для определенной функциональности, такой как JDBC, JPA, Spring Security и другие.

4. **Продакшн-готовность**: Включает различные фичи для мониторинга и управления приложением в продакшен-окружении, такие как метрики, проверки состояния и внешний конфиг.

5. **Легкость создания исполняемых JAR-файлов**: Способность создавать "fat" (или "uber") JAR-файлы, которые включают в себя не только ваше приложение, но и все его зависимости, а также встроенный сервер.

6. **Внешние конфигурации**: Упрощает управление конфигурациями приложения с помощью внешних файлов конфигурации (application.properties или application.yml), что позволяет изменять поведение приложения без изменения кода.

7. **Профили Spring**: Поддержка профилей Spring для разделения конфигурации приложения на разные среды, такие как разработка, тестирование и продакшн.

8. **Логирование**: Spring Boot предоставляет готовые настройки логирования, которые можно легко настроить с помощью внешних файлов конфигурации.

9. **Безопасность**: Включение и настройка Spring Security для обеспечения безопасности веб-приложений становится проще благодаря специализированным "стартерам".

Spring Boot значительно упрощает процесс разработки приложений на Spring, сокращая время настройки и конфигурации, и позволяя разработчикам сосредоточиться непосредственно на бизнес-логике приложения.


### 3. Написать интерфейс форума, где есть темы, сообщения и т.д. Должна быть возможность поставить лайк, написать комментарии. Всё при помощи Rest API. Должно быть минимум 2 React компонента

Компонент форума:

```jsx
import React, { useState, useEffect } from 'react';
import Post from './Post';

function Forum() {
  const [posts, setPosts] = useState([]);

  useEffect(() => {
    const fetchPosts = async () => {
      try {
        const response = await fetch('https://example.com/api/posts');
        if (!response.ok) {
          throw new Error('Ошибка загрузки постов');
        }
        const data = await response.json();
        setPosts(data);
      } catch (error) {
        console.error('Ошибка:', error);
      }
    };

    fetchPosts();
  }, []);

  return (
    <div>
      {posts.map(post => (
        <Post key={post.id} post={post} />
      ))}
    </div>
  );
}

export default Forum;
```

Компонент поста:

```jsx
import React, { useState } from 'react';

function Post({ post }) {
  const [likes, setLikes] = useState(post.likes);
  const [comments, setComments] = useState(post.comments);
  const [newComment, setNewComment] = useState('');

  const handleLike = async () => {
    try {
      const response = await fetch(`https://example.com/api/posts/${post.id}/like`, { method: 'POST' });
      if (!response.ok) {
        throw new Error('Ошибка при лайке');
      }
      setLikes(likes + 1);
    } catch (error) {
      console.error('Ошибка:', error);
    }
  };

  const handleComment = async () => {
    try {
      const response = await fetch(`https://example.com/api/posts/${post.id}/comments`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text: newComment })
      });
      if (!response.ok) {
        throw new Error('Ошибка при добавлении комментария');
      }
      setComments([...comments, newComment]);
      setNewComment('');
    } catch (error) {
      console.error('Ошибка:', error);
    }
  };

  return (
    <div>
      <h3>{post.title}</h3>
      <p>{post.content}</p>
      <button onClick={handleLike}>Like ({likes})</button>
      <div>
        <input 
          type="text" 
          value={newComment} 
          onChange={(e) => setNewComment(e.target.value)}
          placeholder="Написать комментарий..."
        />
        <button onClick={handleComment}>Комментировать</button>
      </div>
      <ul>
        {comments.map((comment, index) => (
          <li key={index}>{comment}</li>
        ))}
      </ul>
    </div>
  );
}

```

## Билет 7

### 1. Handler Mapping в Spring Web MVC

- Механизм, позволяющий распределять запросы по различным обработчикам.
- Помимо «основного» Handler'а, в обработке запроса могут участвовать один или несколько «перехватчиков» (реализаций интерфейса HandlerInterceptor).
- Механизм в общем похож на сервлеты и фильтры.
- «Из коробки» программисту доступно несколько реализаций Handler Mapping.

Некоторые реализации: RequestMappingHandlerMapping, BeanNameUrlHandlerMapping, ControllerClassNameHandlerMapping. Чаще всего используется первый. Анализирует аннотации @RequestMapping и сопоставляет запросы с соответствующими методами.

### 2. JSX. Особенности синтаксиса. Применение в React
- Расширение языка JavaScript
- Сахар для React.createElement(component, props, ...children)
- Компилируется Babel’ом в JS
- Визуально близок к HTML
- Компоненты должны возвращать всегда 1 элемент
- Все теги должны быть закрытыми (<img> -> <img />)
- Почти все теперь в camelCase (className, onClick)
- Под капотом превращается в JS
- Применяется для переиспользования компонентов, условного рендеринга, циклов.

Пример синтаксиса:
```js
class Hello extends React.Component {
render() {
return <div> Hello ${this.props.name}</div>
}
}
ReactDOM.render(
<Hello name=”Вася”/>,
document.getElementById('root')
);
```

### 3.

## Билет 8

### 1. Spring MVC: обработка запроса, dispatcher servlet

Spring MVC основан на сервлетах. Существует диспетчер сервлет, который по маппингу делегирует обработку запросу какому-то методу контроллера. Реализует паттерн MVC.
- После получения HTTP-запроса DispatcherServlet обращается к интерфейсу HandlerMapping, который определяет, какой контроллер должен быть вызван, после чего, отправляет запрос в нужный контроллер.
- Контроллер принимает запрос и вызывает соответствующий метод. Вызванный метод определяет данные модели и возвращает в DispatcherServlet имя View.
- При помощи интерфейса ViewResolver DispatcherServlet определяет, какой view нужно использовать на основании полученного имени.
- После того, как View создан, DispatcherServlet отправляет данные модели в виде атрибутов в view, который в конечном итоге отображается в браузере.


**DispatcherServlet**:
- Обрабатывает все запросы и формирует ответы на них.
- Связывает между собой все элементы архитектуры Spring MVC.
- Обычный сервлет – конфигурируется в web.xml.

### 2. SPA особенности, плюсы и минусы

**Основные идеи:**
- Все веб приложение - единый веб документ
- Обновление документа при помощи AJAX
- Роутинг через Browser History API
- Клиент и сервер реализуются независимо, управляют своим состоянием независимо и взаимодействуют по REST.
- Формат передаваемых данных не специфицирован, но обычно это JSON.

**Преимущества**:
- Быстродействие, т. к. все необходимые ресурсы загружаются при первой загрузке страницы
- Оффлайн режим
- Независимая разработка фронта и бэка
- Улучшенная навигация
- Экономия трафика

**Недостатки**:
- Большинство контента загружается динамически через JS
- Следовательно, проблемы с SEO, аналитикой, security
- Следовательно, не работает при отключенном JS

### 3. Написать Angular интерфейс для ввода данных паспорта, серия 4 цифры, номер 6 цифр, дата, место проживания

```ts
@Component({
  selector: 'app-passport-data',
  templateUrl: './passport-data.component.html'
})
export class PassportDataComponent implements OnInit {
  passportForm: FormGroup;

  constructor(private formBuilder: FormBuilder) {}

  ngOnInit() {
    this.passportForm = this.formBuilder.group({
      series: ['', [Validators.required, Validators.pattern(/^\d{4}$/)]],
      number: ['', [Validators.required, Validators.pattern(/^\d{6}$/)]],
      issueDate: ['', Validators.required],
      place: ['', Validators.required]
    });
  }

  onSubmit() {
    if (this.passportForm.valid) {
      console.log(this.passportForm.value);
      // Обработка данных формы
    }
  }
}
```

```html
<form [formGroup]="passportForm" (ngSubmit)="onSubmit()">
  <div>
    <label for="series">Серия</label>
    <input type="text" id="series" formControlName="series">
  </div>

  <div>
    <label for="number">Номер</label>
    <input type="text" id="number" formControlName="number">
  </div>

  <div>
    <label for="issueDate">Дата выдачи</label>
    <input type="date" id="issueDate" formControlName="issueDate">
  </div>

  <div>
    <label for="place">Место проживания</label>
    <input type="text" id="place" formControlName="place">
  </div>

  <button type="submit" [disabled]="!passportForm.valid">Отправить</button>
</form>
```

## Билет 9

### 1. JNDI. JNDI в Java EE. Способы взаимодействия с JNDI. Их преимущества и недостатки.

Java Naming and Directory Interface (JNDI) — это набор Java API, организованный в виде службы
каталогов, который позволяет Java-клиентам открывать и
просматривать данные и объекты по их именам. 

В контексте Java EE, JNDI используется для поиска и управления ресурсами, такими как JDBC-источники данных, JMS (Java Message Service) соединения и EJB (Enterprise JavaBeans).


**JNDI в Java EE:**

1. **Локализация ресурсов**: JNDI позволяет приложениям находить данные и объекты через логические имена, а не через конкретные ссылки или пути. Это обеспечивает гибкость и упрощает управление ресурсами в распределенной среде.

2. **Интеграция с контейнером**: В Java EE контейнер предоставляет реализацию JNDI, позволяя приложениям легко находить и использовать ресурсы, которые контейнер управляет и конфигурирует.

**Два варианта использования JNDI:**
- CDI (аннотации) — работает только в managed компонентах. В Java EE JNDI часто используется в сочетании с внедрением зависимостей, позволяя автоматически вставлять ресурсы непосредственно в компоненты приложения. Аннотации CDI позволяют автоматизировать процесс поиска и инъекции ресурсов в управляемые компоненты (managed components), такие как EJB, сервлеты или JSF бины.
- Прямой вызов API — работает везде. В явном виде выполняется поиск и работа с ресурсами через JNDI API.

### 1. Прямой доступ к JNDI

Этот подход включает использование JNDI API для непосредственного поиска ресурсов.

#### Плюсы:
- **Гибкость**: Предоставляет полный контроль над тем, как и когда осуществляется доступ к ресурсам.
- **Универсальность**: Подходит для любых типов ресурсов, доступных через JNDI.

#### Минусы:
- **Сложность**: Требует написания дополнительного кода и обработки исключений.
- **Тесная связь с JNDI**: Код становится зависимым от JNDI, что может усложнить тестирование и миграцию.

### 2. Использование Resource Injection

Современные Java EE фреймворки (например, Spring) позволяют инжектировать ресурсы из JNDI напрямую в компоненты с использованием аннотаций.

#### Плюсы:
- **Простота и Читаемость**: Уменьшает количество шаблонного кода и упрощает его понимание.
- **Легкость Интеграции**: Хорошо интегрируется с фреймворками и контейнерами, упрощая конфигурацию и управление.

#### Минусы:
- **Зависимость от контейнера**: Требуется поддержка контейнера для инъекции ресурсов.
- **Меньший контроль**: Разработчики могут иметь меньше контроля над процессом поиска и получения ресурсов.

### 2. React - особенности, плюсы и минусы использования
React - js библиотека для построения UI. 

**Особенности**
- Компоненты и их переиспользование. Каждый компонент представляет собой независимый блок кода, который отвечает за определенную часть пользовательского интерфейса. 
- Декларативность
- JSX разметка: под капотом превращается в JS, компоненты должны возвращать всегда 1 элемент, все в camelCase, закрытые теги
- Легкая интеграция в существующие решения
- Можно писать нативные и фулстек приложения

React, популярная JavaScript библиотека для создания пользовательских интерфейсов, особенно веб-приложений, имеет свои плюсы и минусы. Понимание этих аспектов важно для принятия решения о том, подходит ли React для конкретного проекта.

### Плюсы React:

1. **Компонентный Подход**: React использует компонентный подход, который помогает в построении переиспользуемого и удобно поддерживаемого кода. Компоненты могут быть инкапсулированы, что облегчает управление состоянием и логикой.

2. **Виртуальный DOM**: React использует виртуальный DOM, что обеспечивает оптимизацию производительности. Изменения сначала применяются к виртуальному DOM, а затем, с помощью эффективного алгоритма сравнения, минимально необходимые изменения вносятся в реальный DOM.

3. **Широкое Сообщество и Экосистема**: Огромное сообщество разработчиков и множество доступных ресурсов, библиотек и инструментов.

4. **Гибкость и Интеграция**: React можно использовать в сочетании с различными архитектурами и библиотеками (например, с Redux для управления состоянием).

5. **Поддержка Одностраничных Приложений (SPA)**: React идеально подходит для создания быстрых и интерактивных одностраничных приложений.

### Минусы React:

2. **Только Библиотека, а Не Полноценный Фреймворк**: React отвечает только за слой представления (вид), в отличие от полноценных фреймворков типа Angular, которые предлагают более широкий набор инструментов "из коробки".

5. **Управление Состоянием**: Управление состоянием в крупных приложениях может стать сложным без использования дополнительных библиотек, таких как Redux.

6. **SEO Оптимизация**: Для одностраничных приложений на React может потребоваться дополнительная работа для оптимизации под поисковые системы

### 3. Форма для отправки сообщения в поддержку на Thymeleaf и Spring MVC. С выбором причины(select), полем для email и текстовым полем проблемы

DTO:
```java
public class SupportMessageDTO {
    private String email;
    private String reason;
    private String message;

    // Геттеры и сеттеры
}
```
Controller:
```java
@Controller
public class SupportController {

    @GetMapping("/support")
    public String showSupportForm(Model model) {
        model.addAttribute("supportMessage", new SupportMessageDTO());
        return "support-form";
    }

    @PostMapping("/support")
    public String submitSupportForm(SupportMessageDTO supportMessage) {
        // Обработка сообщения...
    }
}
```

Шаблон страницы:

```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <title>Support Form</title>
</head>
<body>
    <form th:action="@{/support}" th:object="${supportMessage}" method="post">
        <div>
            <label for="reason">Причина обращения:</label>
            <select th:field="*{reason}">
                <option value="Technical">Техническая проблема</option>
                <option value="Account">Вопросы аккаунта</option>
                <option value="Other">Другое</option>
            </select>
        </div>
        <div>
            <label for="email">Email:</label>
            <input type="email" th:field="*{email}" />
        </div>
        <div>
            <label for="message">Сообщение:</label>
            <textarea th:field="*{message}"></textarea>
        </div>
        <div>
            <button type="submit">Отправить</button>
        </div>
    </form>
</body>
</html>
```

## Билет 10

### 1. Профили платформы Java/Jakarta EE.

Java EE представляет собой набор спецификаций, предназначенных для разработки масштабируемых, многоуровневых, надежных и безопасных сетевых приложений. В рамках Java EE существуют различные профили, каждый из которых предназначен для определенных целей и задач

### Основные Профили Java EE:

1. **Full Profile**: 
   - **Описание**: Полная платформа Java EE включает в себя все спецификации Java EE, предоставляя полный набор возможностей для создания корпоративных приложений.
   - **Ключевые Технологии**: EJB (Enterprise JavaBeans), JPA (Java Persistence API), JMS (Java Message Service), JAX-RS (Java API for RESTful Web Services), JAX-WS (Java API for XML-Based Web Services), JSF (JavaServer Faces) и другие.
   - **Использование**: Идеально подходит для крупных, многоуровневых корпоративных приложений, требующих широкой функциональности и интеграции различных компонентов.

2. **Web Profile**: 
   - **Описание**: Профиль Web представляет собой упрощенный набор спецификаций, ориентированный на веб-приложения. Он включает основные технологии, необходимые для разработки веб-приложений, без более сложных и тяжеловесных компонентов, характерных для полной платформы.
   - **Ключевые Технологии**: Servlets, JSP (JavaServer Pages), JSF, JPA, JTA (Java Transaction API), CDI (Contexts and Dependency Injection), Bean Validation.
   - **Использование**: Подходит для разработки веб-приложений, где не требуется полный набор спецификаций Java EE.
  

### 2. Способы реализации DI в Spring. @Qualifier.

**Через конструктор:**

Просто передаем бин конструктору. Если несколько конструкторов, то нужно указать @Autowired к какому-то конструктору, чтобы Спринг знал, какой использовать для внедрения зависимостей. Рекомендуется для внедрения обязательных зависимостей.

**Через сеттер:**
Спринг вызовет этот метод для внедрения зависимостей. Рекомендуется использовать для внедрения опциональных зависимостей.

**Через поле:**
Спринг просто внедрит зависимость в это поле. Часто используется из-за своей простоты и удобства, так как не требует написания дополнительного кода. Не рекомендуется использовать Field Injection для обязательных зависимостей из-за сложности в тестировании и потенциальных проблем с порядком инициализации. Также не может использоваться для присвоения зависимостей final полям.


Аннотация @Qualifier в Spring Framework используется для уточнения выбора бина при внедрении зависимостей, когда в контексте приложения существует более одного бина одного и того же типа. Это позволяет более точно указать, какой именно бин должен быть внедрен, предотвращая возможные конфликты и ошибки.

Можно определить квалификаторы, аннотируя бины с @Qualifier и указывая уникальное имя. Это имя затем используется для идентификации нужного бина при внедрении зависимостей.

```java
Copy code
@Component
@Qualifier("mainDataService")
public class MainDataService implements DataService {
    // ...
}

@Component
@Qualifier("secondaryDataService")
public class SecondaryDataService implements DataService {
    // ...
}
```

### 3. Интерфейс на Angular, формирующий две страницы URL - «Главную» (/home) и «Новости» (/news). Переход между страницами должен осуществляться посредством гиперссылок.

App-Routing:

```ts
const routes: Routes = [
  {path: 'home', component: HomeComponentComponent},
  {path: 'news', component: NewsComponentComponent}
];
```

HomeComponent:
```html
<p>This is Home page</p>
<a routerLink="/news">News</a>
```

NewsComponent:
```html
<p>This is News page</p>
<a routerLink="/home">Home</a>
```

AppComponent:

```html
<router-outlet></router-outlet>
```


## Билет 11

### 1. Построение пользовательского интерфейса в JSF. Иерархия компонентов JSF

Интерфейс строится из компонентов. 
- Компоненты расположены на Facelets-шаблонах или страницах JSP. 
- Компоненты реализуют интерфейс javax.faces.component.UIComponent. 
- Можно создавать собственные компоненты.
- Компоненты на странице объединены в древовидную структуру — представление. 
- Корневым элементов представления является экземпляр класса javax.faces.component.UIViewRoot.

Сам шаблон интерфейса располагается на Facelets и состоит из комбинации различных тегов. Можно создавать свои компоненты отнаследовав их от необходимого класса/интерфейса и встраивать в facelets

### 2. CDI Beans: принципы инъекции. Способы разрешения ситуации неоднозначных зависимостей (2 бина реализуют 1 интерфейс)

CDI (Contexts and Dependency Injection) в Java EE и Jakarta EE предоставляет мощные возможности для управления зависимостями и жизненным циклом бинов. Основной принцип инъекции заключается в автоматическом управлении зависимостями между компонентами, что упрощает разработку и поддержку приложений.

### Принципы Инъекции в CDI

1. **Автоматическое Внедрение**: CDI контейнер автоматически внедряет зависимости в бины через конструкторы, сеттеры или поля.
2. **Типобезопасность**: CDI обеспечивает типобезопасность при внедрении, что снижает риск ошибок во время выполнения.
3. **Контекстная Зависимость**: Бины могут быть связаны с определенными контекстами (например, запросом, сессией), что позволяет управлять их жизненным циклом.

### Разрешение Неоднозначных Зависимостей

Когда два или более бина реализуют один интерфейс, возникает неоднозначность зависимостей. Для разрешения этой ситуации в CDI есть несколько способов:

1. **Аннотация @Default**: Используется по умолчанию, когда не указано другое квалификационное имя. Если один из бинов отмечен как `@Default`, CDI будет использовать его, когда точный квалификатор не указан.

2. **Создание Собственных Квалификаторов**:
   - Определите собственный квалификатор с аннотацией `@Qualifier`.
   - Примените этот квалификатор к нужному бину.
   - Укажите тот же квалификатор при внедрении зависимости.

   ```java
   @Qualifier
   @Retention(RUNTIME)
   @Target({METHOD, FIELD, PARAMETER, TYPE})
   public @interface MyQualifier {}

   @MyQualifier
   public class MyBeanImpl implements MyInterface {}

   @Inject
   @MyQualifier
   private MyInterface myBean;
   ```

3. **Аннотация @Alternative**:
   - Отметьте один из бинов как `@Alternative`.
   - Активируйте этот альтернативный бин в файле `beans.xml`.

   ```java
   @Alternative
   public class AlternativeBeanImpl implements MyInterface {}

   <!-- В beans.xml -->
   <beans>
       <alternatives>
           <class>com.example.AlternativeBeanImpl</class>
       </alternatives>
   </beans>
   ```

4. **Использование @Named**:
   - Используйте аннотацию `@Named` для присвоения бинам уникальных имен.
   - Внедрите зависимость, указав имя с помощью аннотации `@Inject`.

   ```java
   @Named("myNamedBean")
   public class MyBeanImpl implements MyInterface {}

   @Inject
   @Named("myNamedBean")
   private MyInterface myBean;
   ```

### 3. Angular: приложение, принимающее имя и дату и формирующее бланк ПСЖ на клиенте

```ts
@Component({
  selector: 'app-rubezhka-auth-interface',
  templateUrl: './rubezhka-auth-interface.component.html',
  styleUrls: ['./rubezhka-auth-interface.component.scss']
})
export class RubezhkaAuthInterfaceComponent implements OnInit {

  name: string = ''
  date: string = ''
  document: string = ''

  constructor() { }


  generateDocument(){
    this.document = `Я, ${this.name}, прошу отчислить меня из университета по собственному желанию с ${this.date}`
  }


  ngOnInit(): void {
  }

}
```

```html
<div>
  <form (ngSubmit)="generateDocument()">
      <input  name="name" [(ngModel)]="name" type="text" required>

      <input type="date" [(ngModel)]="date"  name="date" required>

    <button type="submit">Create PSG</button>
  </form>

  <div *ngIf="document">
    <h2>PSG</h2>
    <p>{{document}}</p>
  </div>
</div>
```

## Билет 12

### 1. Ангуляр: шаблоны, представление

**Шаблоны (Templates)**
Шаблоны в Angular - это HTML-представления, которые используют Angular-расширения. Они могут включать директивы, привязки данных и другие конструкции Angular.

- Директивы: Указания Angular о том, как должен работать DOM при изменении данных. По своей реализации директивы практически идентичны компонентам (компонент — это директива с HTML-шаблоном). Есть два вида директив: структурные (добавляют, удаляют или заменяют элементы в DOM. Примеры: *ngIf, *ngFor) и атрибуты (задают элементу другое поведение. Примеры: [ngStyle], [ngClass]).
- Привязка данных: Механизмы, позволяющие связывать свойства в классе компонента с элементами в шаблоне. Существует несколько форм привязки данных:

1. Односторонняя привязка данных:

- Интерполяция: Используется для вывода значения свойства компонента в HTML. Записывается как {{ value }}, где value — свойство компонента.
- Привязка свойств (Property Binding): Позволяет установить значение свойства элемента HTML из компонента. Пример: [property]="value".
- Привязка событий (Event Binding): Позволяет компоненту реагировать на события в шаблоне. Пример: (event)="handler()".

2. Двусторонняя привязка данных:

- NgModel: Используется для форм и инпутов. Позволяет синхронизировать значение поля формы в шаблоне с соответствующим свойством в компоненте. Записывается как [(ngModel)]="property".

3. Привязка стилей и классов:

- Привязка классов: Позволяет динамически управлять классами элементов. Например, [class.special]="isSpecial".
- Привязка стилей: Позволяет установить стили элемента динамически. Например, [style.color]="isSpecial ? 'red' : 'green'".

Как это работает:

- При изменении данных в компоненте, шаблон автоматически обновляется для отображения новых значений.
- В случае двусторонней привязки, изменения в шаблоне также обновляют данные в компоненте.

- Пайпы (Pipes): Позволяют осуществлять преобразование формата отображаемых данных (например, дат или денежных сумм) прямо в шаблоне. Например, {{ date | date:'shortDate' }} преобразует объект Date в короткую дату. Фильтры можно объединять в последовательности (pipe chains). 


**Представления (Views)**
Представления - это то, что создается на основе шаблонов и модели данных компонента при рендеринге компонента. 
- Компоненты и их шаблоны формируют представления
- Компонент может содержать *иерархию представлений*, которая содержит *встроенные представления* из других компонентов
- Каждый компонент содержит *корневое представление* (host view)

### 2. Спринг Бут, зачем он нужен. Стартеры

Зачем нужен - в 6м билете

**Стартеры**

Стартеры в Spring Boot — это набор удобных зависимостей, которые можно добавить в проект, чтобы получить функциональность, связанную с определенной технологией или задачей, без необходимости вручную определять совместимые версии каждой библиотеки. Эти стартеры упрощают процесс конфигурации проекта, предоставляя предварительно настроенные зависимости, которые работают вместе "из коробки".

### Ключевые особенности стартеров в Spring Boot:

1. **Упрощение зависимостей**: Стартеры содержат группу совместимых зависимостей, упрощая процесс настройки.
2. **Автоматическая конфигурация**: Благодаря Spring Boot автоконфигурации, стартеры помогают автоматически настроить проект в соответствии с добавленными зависимостями.
3. **Совместимость версий**: Стартеры обеспечивают совместимость между различными библиотеками, устраняя проблемы совместимости версий.

### Примеры популярных стартеров Spring Boot:

- **spring-boot-starter-web**: Для создания веб-приложений, включая RESTful приложения, использующих Spring MVC. Включает в себя Tomcat как встроенный контейнер сервлетов.
- **spring-boot-starter-data-jpa**: Для использования Spring Data JPA с Hibernate для работы с реляционными базами данных.
- **spring-boot-starter-security**: Для интеграции Spring Security в приложение.
- **spring-boot-starter-test**: Для тестирования приложений Spring Boot с помощью библиотек, таких как JUnit, Hamcrest и Mockito.
- **spring-boot-starter-thymeleaf**: Для использования шаблонизатора Thymeleaf в веб-приложениях.
- **spring-boot-starter-actuator**: Предоставляет продакшн-готовые функции для мониторинга и управления приложением.
- **spring-boot-starter-mail**: Для отправки электронной почты.

### 3. Конфигурация, чтобы JSF обрабатывал все запросы приходящие с .xhtml и со всех URL, начинающихся с /faces/

```xml
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
                             http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">

    <!-- Faces Servlet -->
    <servlet>
        <servlet-name>Faces Servlet</servlet-name>
        <servlet-class>javax.faces.webapp.FacesServlet</servlet-class>
        <load-on-startup>1</load-on-startup>
    </servlet>

    <!-- Map all URLs ending with .xhtml -->
    <servlet-mapping>
        <servlet-name>Faces Servlet</servlet-name>
        <url-pattern>*.xhtml</url-pattern>
    </servlet-mapping>

    <!-- Map all URLs starting with /faces/ -->
    <servlet-mapping>
        <servlet-name>Faces Servlet</servlet-name>
        <url-pattern>/faces/*</url-pattern>
    </servlet-mapping>

    <!-- Other configurations -->

</web-app>
```

## Билет 13

### 1. MVC-модель JSF.

**Controller** в JSF – FacesServlet, главный сервлет в JSF, обрабатывает запросы с браузера, формирует объекты-события и вызывает методы-слушатели. Конфигурируется в web.xml

**View**: JSF-страницы (XHTML или JSP).
- Интерфейс строится из компонентов.
- Компоненты расположены на Facelets-шаблонах или страницах JSP, реализуют интерфейс javax.faces.component.UIComponent.
- Можно создавать собственные компоненты.
- Компоненты на странице объединены в древовидную структуру — представление.

**Model**: Managed beans. Вместо них можно использовать CDI, EJB или Spring бины.
- Конфиг с помощью аннотаций или устаревшего xml.
- Содержат параметры и методы для обработки данных с компонентов.
- Используются для обработки событий UI и валидации данных.
- Жизненным циклом управляет JSF Runtime Environment.

### 2. Java\Jakarta EE CDI Beans: основные аннотации.

- @Named для именования бинов
- @Inject как @Autowired в Spring, для внедрения зависимостей
- @Alternative позволяет указывать конкретную реализацию интерфейса/абстрактного класса на лету для использования разных реализаций в разных ситуациях
- @Produces, @Disposes – методы для создания и уничтожения бинов соответственно (@Disposes помечается параметр метода)
- @Observes – используется в методе-наблюдателе для обработки события, помечается параметр метода
- @Stereotype - аннотации, включающие в себя другие аннотации. Используются в больших и сложных приложениях, где есть много бинов, выполняющих схожие действия.

Стереотип может задавать:
- Контекст (scope) по-умолчанию.
- Любое число назначенных перехватчиков.
- Опционально – аннотацию @Named, специфицирующую имя, под которым бин будет виден из EL.
- Опционально – аннотацию @Alternative, специфицирующую то, что бины внутри этого стереотипа являются альтернативами друг другу.

Interceptors – классы, реагирующие на определенные события ЖЦ бинов, например @PostConstruct, @PreDestroy, @AroundInvoke и т.д. Похожи на фильтры в сервлетах.

### 3. Страница, построенная с помощью React, реализующая таблицу со списком пользователей системы (два поля — screenName и fullName). Таблица должна поддерживать поиск по fullName (правило поиска - «содержит, с учетом регистра»). Нужно использовать минимум 2 React компонента.

```jsx
const SearchBar = ({ onSearch }) => {
  return (
    <input
      type="text"
      placeholder="Поиск по имени..."
      onChange={(e) => onSearch(e.target.value)}
    />
  );
};

export default SearchBar;
```

```jsx
const UserTable = ({ users }) => {
  return (
    <table>
      <thead>
        <tr>
          <th>Screen Name</th>
          <th>Full Name</th>
        </tr>
      </thead>
      <tbody>
        {users.map((user, index) => (
          <tr key={index}>
            <td>{user.screenName}</td>
            <td>{user.fullName}</td>
          </tr>
        ))}
      </tbody>
    </table>
  );
};

export default UserTable;
```

Главный компонент:

```jsx
const App = () => {
  const [initialUsers, setInitialUsers] = useState([]);
  const [filteredUsers, setFilteredUsers] = useState([]);

  useEffect(() => {
    // Замените этот код на запрос к API или другой источник данных
    const usersData = [
      { screenName: 'user1', fullName: 'John Doe' },
      { screenName: 'user2', fullName: 'Jane Smith' },
      // Другие пользователи
    ];
    setInitialUsers(usersData);
    setFilteredUsers(usersData);
  }, []);

  const handleSearch = (searchTerm) => {
    const filtered = initialUsers.filter(user =>
      user.fullName.toLowerCase().includes(searchTerm.toLowerCase())
    );
    setFilteredUsers(filtered);
  };

  return (
    <div>
      <SearchBar onSearch={handleSearch} />
      <UserTable users={filteredUsers} />
    </div>
  );
};

export default App;
```
## Билет 14

### 1. Платформы Java. Особенности, сходства и различия

Java является универсальным языком программирования, который используется в различных областях, начиная от встроенных систем и заканчивая крупномасштабными предприятиями. Платформы Java различаются по своему назначению и предоставляемому функционалу, и включают в себя следующие основные категории:

### 1. Java Standard Edition (Java SE)

- **Особенности**: Является стандартной платформой для разработки и запуска приложений на языке Java. Включает в себя базовый набор библиотек и API, таких как коллекции, потоки ввода-вывода, утилиты для работы с сетью, базовые инструменты для графического интерфейса (Swing и JavaFX) и другие основные компоненты.
- **Использование**: Разработка настольных приложений, консольных утилит, базовых серверных компонентов.

### 2. Java Enterprise Edition (Java EE) / Jakarta EE

- **Особенности**: Расширяет Java SE, добавляя библиотеки и API для разработки и запуска масштабируемых, многоуровневых, надежных и безопасных корпоративных приложений. Включает в себя такие технологии, как Servlets, JavaServer Pages (JSP), Enterprise JavaBeans (EJB), RESTful и SOAP веб-сервисы и другие.
- **Использование**: Разработка крупномасштабных предприятий и веб-приложений, систем электронной коммерции, корпоративных систем.

### 3. Java Micro Edition (Java ME)

- **Особенности**: Оптимизирована для мобильных устройств и встроенных систем. Включает в себя подмножество функционала Java SE и дополнительные библиотеки, специфичные для мобильных устройств и встроенных систем.
- **Использование**: Разработка приложений для мобильных телефонов, смарт-устройств, встроенных систем.

### Сходства и Различия

- **Сходства**:
  - Все платформы базируются на языке Java, что обеспечивает единообразие синтаксиса и основных принципов программирования.
  - Основаны на концепции "Write Once, Run Anywhere" (WORA), предполагающей кросс-платформенность.
  - Используют виртуальную машину Java (JVM) для выполнения скомпилированного байт-кода.

- **Различия**:
  - **Java SE** ориентирована на стандартные приложения, включая настольные и серверные приложения.
  - **Java EE / Jakarta EE** расширяет Java SE, предоставляя дополнительные инструменты и API для разработки и развертывания крупных корпоративных приложений.
  - **Java ME** предназначена для мобильных и встроенных устройств с ограниченными ресурсами и предлагает API, специфичные для такого рода устройств.


### 2. Двухфазные и Трёхфазные конструкторы в Spring, JavaEE

Три фазы:
- Сам конструктор, вызываемый при создании экземпляра бина
- Метод, который должен быть выполнен после завершения конструктора и внедрения всех зависимостей
- BeanPostProcessor - интерфейс Spring, который предоставляет возможность вмешиваться в жизненный цикл бина, предварительно и после его инициализации

Java EE: двухфазный конструктор – сам конструктор и метод @PostConstruct.

Spring: можно сделать трехфазный конструктор – собственно конструктор, метод @PostConstruct, и написать свой BeanPostProcessor, который будет производить дополнительные действия с бином до/после инициализации.

### 3. JSF страница, которая выводит 10 простых чисел, а затем ajax'ом динамически подгружает остальные пачками по 10

```html
<html xmlns="http://www.w3.org/1999/xhtml"
xmlns:h="http://xmlns.jcp.org/jsf/html"
xmlns:f="http://xmlns.jcp.org/jsf/core">
<h:head>
<title>Prime Numbers</title>
</h:head>
<h:body>
<h:form id="primeForm">
<h:outputText value="First 10 prime numbers: " />
<h:outputText value="#{primeBean.primes}" />
<br/>
<h:commandButton value="Load Next 10 Primes" action="#{primeBean.loadNextTenPrimes}">
<f:ajax render="primeForm" />
</h:commandButton>
</h:form>
</h:body>
</html>
@ManagedBean
@SessionScoped
public class PrimeBean implements Serializable {
private List<Integer> primes = new ArrayList<>();
private int count = 0;
// Конструктор бина
public PrimeBean() {
count = 10;
getPrimes(count);
}
// Метод для генерации простых чисел
private void getPrimes(int count) {
primes = …; // получаем count простых чисел и сохраняем в список
}
public void loadNextTenPrimes() {
count += 10;
primes = getPrimes(count);
}
}
```
## Билет 15

### 1. Валидация JSF. Создание, назначение и виды валидации.

- Осуществляется перед обновлением значения
компонента на уровне модели.
- Класс, осуществляющий валидацию, должен
реализовывать интерфейс
javax.faces.validator.Validator.
- Существуют стандартные валидаторы для
основных типов данных.
- Можно создавать собственные валидаторы.

**Способы валидации:**
- С помощью параметров компонента (аттрибут `required="true"`)
- С помощью вложенного тега (пример: вложенный в `<h:inputText>` тег `<f:validateDoubleRange minimum="-5" maximum="5"/>`)
- С помощью логики на уровне managed bean (аннотации, кастомные методы...)

### 2. Назначение и реализация контроллера Spring MVC

Controller – обрабатывает запрос пользователя,
создаёт соответствующую модель и передаёт её
для отображения в представление.
- Класс, который связывает модель с
представлением, управляет состоянием модели.
- Помечается аннотацией @Controller.
- Класс или его методы могут быть помечены
  аннотациями, «привязывающими» их к
  определённым методам HTTP или URL (`@RequestMapping` или аннотации-сокращения типа `@GetMapping`, `@PostMapping` и т.д., чтобы маппинговать URL-адреса на конкретные методы.).
- Аннотации @RequestParam, @PathVariable, @RequestBody и другие используются для извлечения данных из запросов.

Здесь выполняется бизнес-логика, обработка данных из запроса, взаимодействие с Model (сервисы, компоненты доступа к данным и т.д.) и возвращается некоторый результат, обычно в виде имени представления и модели данных для этого представления (объект `ModelAndView`) или `ResponseEntity`.

### 3. Чат- бот на Ангуляре. На каждое сообщение от пользователя бот должен отвечать «Сам дурак». Нужно указать автора, дату


Интерфейс:

```ts
// message.model.ts
export interface Message {
  author: string;
  content: string;
  date: Date;
}
```

Компонент:

```ts
@Component({
  selector: 'app-chatbot',
  templateUrl: './chatbot.component.html',
  styleUrls: ['./chatbot.component.css']
})
export class ChatbotComponent {
  messages: Message[] = [];
  newMessageContent: string = '';

  sendMessage() {
    if (!this.newMessageContent.trim()) return;

    const userMessage: Message = {
      author: 'User',
      content: this.newMessageContent,
      date: new Date()
    };

    this.messages.push(userMessage);

    const botResponse: Message = {
      author: 'Bot',
      content: 'Сам дурак',
      date: new Date()
    };

    setTimeout(() => this.messages.push(botResponse), 1000);

    this.newMessageContent = '';
  }
}
```

Шаблон:

```ts
<!-- chatbot.component.html -->
<div class="chat-container">
  <div class="messages">
    <div *ngFor="let message of messages">
      <p><strong>{{ message.author }}</strong> ({{ message.date | date:'short' }}): {{ message.content }}</p>
    </div>
  </div>
  <div class="message-input">
    <input type="text" [(ngModel)]="newMessageContent">
    <button (click)="sendMessage()">Отправить</button>
  </div>
</div>
```

## Билет 16

### 1. Spring Web MVC: View Resolvers

- Представление в Spring Web MVC может быть построено на разных технологиях.
- С каждым представлением сопоставляется его символическое имя.
- Преобразованием символических имён в ссылки на конкретные представления занимается специальный класс, реализующий интерфейс org.springframework.web.servlet.ViewResolver.
- Существует много реализаций ViewResolver для разных технологий построения представления.
- В одном приложении можно использовать несколько ViewResolver'ов.
- Требуют конфигурации, описывающей, какие резолверы умеют рендерить какие view.

### 2. Хуки в React. Что это ? Для чего нужны ?

Хуки в React — это функции, которые позволяют использовать возможности состояния и жизненного цикла React в функциональных компонентах. До появления хуков эти возможности были доступны только в классовых компонентах. Хуки были введены в React с версии 16.8 и они предоставляют более удобный и простой способ работы со состоянием и другими функциями React без написания классов.

### Какие Бывают Хуки

1. **useState**: Позволяет добавить состояние React к функциональным компонентам.
2. **useEffect**: Используется для выполнения побочных эффектов в функциональных компонентах (аналог методов жизненного цикла в классовых компонентах).
3. **useContext**: Дает возможность использовать контекст React без необходимости использования Consumer.
4. **useReducer**: Предоставляет альтернативный способ использования состояния, основанный на паттерне Reducer.
5. **useRef**: Возвращает изменяемый ref-объект.
6. **useCallback**: Возвращает мемоизированный колбэк.
7. **useMemo**: Возвращает мемоизированное значение.
8. **useImperativeHandle**: Используется в сочетании с `forwardRef` для модификации родительского компонента.
9. **useLayoutEffect**: Аналогичен `useEffect`, но вызывается синхронно после всех изменений в DOM.
10. **useDebugValue**: Используется для отображения метки для пользовательских хуков в React DevTools.


### Правила Использования Хуков

1. **Только на Верхнем Уровне**: Не используйте хуки внутри циклов, условий или вложенных функций.
2. **Только из Функциональных Компонентов React**: Не вызывайте хуки из обычных JavaScript-функций. Используйте их только в функциональных компонентах React или пользовательских хуках.

### 3. Написать веб-приложение на JSF (xhtml + CDI-бин) со списком студентов и бин, который будет реализовывать логику отчисления студентов. Напротив каждого имени студента должна быть кнопка "отчислить". Обновление должно производиться при помощи AJAX

```html
public class Student {
private String name;
private boolean expelled;
// Геттеры и сеттеры
}
@Named
@ApplicationScoped
public class StudentBean implements Serializable {
private List<Student> students;
@PostConstruct
public void init() {
students = new ArrayList<>();
}
public List<Student> getStudents() {
return students;
}
public void expelStudent(Student student) {
student.setExpelled(true);
}
}
<html xmlns="http://www.w3.org/1999/xhtml"
xmlns:h="http://xmlns.jcp.org/jsf/html"
xmlns:f="http://xmlns.jcp.org/jsf/core">
<h:head>
…
</h:head>
<h:body>
<h:dataTable id="table" value="#{studentBean.students}" var="student">
<h:column>
#{student.name}
</h:column>
<h:column>
<h:commandButton value="Отчислить" action="#{studentBean.expelStudent(student)}">
<f:ajax render="table" />
</h:commandButton>
</h:column>
<h:column rendered="#{student.expelled}">
Отчислен
</h:column>
</h:dataTable>
</h:body>
</html>
```


## Билет 17

### 1. Конвертация, реализация конвертеров в JSF.

- Используются для преобразования данных в заданный формат
- Реализуют интерфейс javax.convert.Converter
- Стандартные конверторы для основных типов данных (javax.faces.Boolean, javax.faces.DateTime, javax.faces.Double, javax.faces.Character, etc.)
- JSF также позволяет создавать собственные конверторы:

Для создания конвертера нужно реализовать интерфейс `javax.faces.convert.Converter` (Этот интерфейс требует реализации двух методов: `getAsObject()` и `getAsString()`), а потом зарегистрировать конвертер через аннотацию `@FacesConverter`


**Назначение конвертеров:**
- Автоматическое (на основании типа данных):
```<h:inputText value="#{user.age}"/>```

- С помощью атрибута converter:
```js
<h:inputText
converter="#{javax.faces.DateTime}"/>
```

- С помощью вложенного тега:
```js
<h:outputText value="#{user.birthDay}">
<f:converter
converterId="#{javax.faces.DateTime}"/>
</h:outputText>
```

### 2. Представление уровня доступа к данным с помощью Spring Data JPA. Концепция, конфигурация.

Spring Data JPA (Java Persistence API) — это часть экосистемы Spring Data, предназначенная для упрощения реализации слоя доступа к данным в приложениях. Она обеспечивает более высокоуровневый и удобный способ взаимодействия с базами данных, скрывая большую часть стандартного кода, связанного с управлением сущностями и запросами.

### Концепция

1. **Репозитории**: Основная концепция Spring Data JPA заключается в использовании интерфейсов репозиториев для определения операций с данными. Spring Data автоматически создает реализацию на основе названий методов в интерфейсе.

2. **Сущности JPA**: Сущности представляют таблицы базы данных и их поля отображаются на столбцы этих таблиц. Сущности аннотируются с помощью аннотаций из спецификации JPA (`@Entity`, `@Id`, `@Column`, и др.).

3. **Spring Data Repository**: Spring Data предоставляет различные типы репозиториев (например, `CrudRepository`, `PagingAndSortingRepository`), которые предлагают различные операции для взаимодействия с базой данных (например, сохранение, удаление, поиск).

### Конфигурация

1. **Зависимости**: Добавьте зависимости Spring Data JPA и соответствующего драйвера базы данных в ваш файл `pom.xml` (Maven) или `build.gradle` (Gradle).

   ```xml
   <!-- Для Maven -->
   <dependencies>
       <dependency>
           <groupId>org.springframework.boot</groupId>
           <artifactId>spring-boot-starter-data-jpa</artifactId>
       </dependency>
       <dependency>
           <groupId>соответствующая_база_данных</groupId>
           <artifactId>соответствующий_драйвер</artifactId>
       </dependency>
   </dependencies>
   ```

2. **Конфигурация DataSource**: Настройте источник данных в файле `application.properties` или `application.yml`. Здесь вы определите параметры подключения к базе данных, такие как URL, имя пользователя, пароль и другие настройки.

   ```properties
   spring.datasource.url=jdbc:url_базы_данных
   spring.datasource.username=имя_пользователя
   spring.datasource.password=пароль
   ```

3. **Аннотация `@Entity`**: Определите сущности JPA, аннотируя классы моделей с `@Entity`. Эти классы представляют таблицы в вашей базе данных.

   ```java
   @Entity
   public class User {
       @Id
       @GeneratedValue(strategy = GenerationType.IDENTITY)
       private Long id;

       // другие поля и методы
   }
   ```

4. **Репозиторий**: Создайте интерфейс репозитория, расширяющий один из интерфейсов Spring Data Repository. В этом интерфейсе вы можете определить пользовательские методы для доступа к данным.

   ```java
   public interface UserRepository extends JpaRepository<User, Long> {
       // Определение пользовательских запросов
       List<User> findByLastName(String lastName);
   }
   ```

### Преимущества использования Spring Data JPA

- **Уменьшение шаблонного кода**: Автоматическая реализация репозиториев устраняет необходимость в написании большинства кода CRUD.
- **Легкость в использовании**: Простота в определении запросов через названия методов.
- **Поддержка пагинации и сортировки**: Встроенные возможности для пагинации и сортировки данных.
- **Интеграция

 с JPA/Hibernate**: Spring Data JPA работает поверх стандартных JPA провайдеров, таких как Hibernate, обеспечивая мощные возможности ORM.
- **Поддержка транзакций**: Управление транзакциями через декларативные аннотации.

### 3. Интерфейс на React где реализуется постраничный просмотр списка студентов (табельный номер, ФИО, группа), также снабженный кнопками "назад" и "вперёд". Ещё нужен поле поиска, где также принимаются параметры "содержит", "без учета регистра"

Компонент студента
```jsx
const Student = ({ student }) => {
  return (
    <tr>
      <td>{student.id}</td>
      <td>{student.name}</td>
      <td>{student.group}</td>
    </tr>
  );
};
```
Компонент списка студентов

```jsx
const StudentList = ({ students }) => {
  return (
    <table>
      <thead>
        <tr>
          <th>Табельный номер</th>
          <th>ФИО</th>
          <th>Группа</th>
        </tr>
      </thead>
      <tbody>
        {students.map(student => <Student key={student.id} student={student} />)}
      </tbody>
    </table>
  );
};
```
Пагинация:

```jsx
const Pagination = ({ currentPage, totalPages, onPageChange }) => {
  return (
    <div>
      <button onClick={() => onPageChange(currentPage - 1)} disabled={currentPage === 1}>Назад</button>
      <span>Страница {currentPage} из {totalPages}</span>
      <button onClick={() => onPageChange(currentPage + 1)} disabled={currentPage === totalPages}>Вперёд</button>
            </div>
    </div>
  );
};
```

Основной компонент:

```jsx
const App = () => {
  const [students, setStudents] = useState(initialStudents); // initialStudents - начальный список студентов
  const [searchTerm, setSearchTerm] = useState('');
  const [currentPage, setCurrentPage] = useState(1);
  const studentsPerPage = 10;

  const filteredStudents = students.filter(student =>
    student.name.toLowerCase().includes(searchTerm.toLowerCase())
  );

  const totalPages = Math.ceil(filteredStudents.length / studentsPerPage);
  const startIndex = (currentPage - 1) * studentsPerPage;
  const currentStudents = filteredStudents.slice(startIndex, startIndex + studentsPerPage);

  const handlePageChange = pageNumber => {
    setCurrentPage(pageNumber);
  };

  const handleSearchChange = event => {
    setSearchTerm(event.target.value);
    setCurrentPage(1); // Возвращаемся на первую страницу при поиске
  };

  return (
    <div>
      <input
        type="text"
        placeholder="Поиск по ФИО..."
        value={searchTerm}
        onChange={handleSearchChange}
      />
      <StudentList students={currentStudents} />
      <Pagination
        currentPage={currentPage}
        totalPages={totalPages}
        onPageChange={handlePageChange}
      />
    </div>
  );
};

export default App;
```

## Билет 18

### 1. Java EE/Jakarta CDI бины. Что это и зачем нужны, если есть ManagedBean и EJB

Contexts and Dependency Injection (CDI) в Java EE представляет собой мощный инструмент для управления зависимостями и контекстами в приложениях. CDI beans дополняют возможности Managed Beans и Enterprise JavaBeans (EJB), обеспечивая более гибкое управление зависимостями и более широкий спектр функций. Вот основные причины, по которым CDI beans используются наряду или вместо Managed/EJB beans:

### 1. Улучшенное Управление Зависимостями

- **Типобезопасные зависимости**: CDI позволяет более безопасно и удобно инжектировать зависимости, используя аннотации типа `@Inject`. Это делает код более чистым и устойчивым к ошибкам.
- **Квалификаторы и Продюсеры**: CDI предоставляет квалификаторы (`@Qualifier`) и продюсеры (`@Produces`), позволяя более точно управлять инъекцией зависимостей.

### 2. Гибкость и Модульность

- **Декораторы и Интерцепторы**: CDI предлагает механизмы для декорирования бинов и использования перехватчиков, что облегчает добавление перехрестной функциональности, такой как логирование и транзакции.
- **Событийная модель**: CDI поддерживает событийно-ориентированное программирование, позволяя компонентам взаимодействовать друг с другом через события.

### 3. Интеграция с Java EE

- **Единообразие в Java EE**: CDI обеспечивает стандартизированный способ управления зависимостями во всех компонентах Java EE, включая JPA, JSF, EJB и другие.
- **Портативность**: Код, написанный с использованием CDI, легко переносится между различными Java EE серверами.

### 4. Улучшенное Управление Жизненным Циклом

- **Расширенные области видимости**: CDI предлагает гибкие области видимости, включая пользовательские, что позволяет более точно управлять жизненным циклом бинов.

### 5. Замена и Дополнение к EJB

- **Легковесность**: CDI beans могут служить легковесной альтернативой EJB для некоторых задач, особенно когда не требуется полный спектр функций EJB, таких как удаленный доступ или управление транзакциями.


### 2. Java Server Faces. Что это, преимущества и недостатки

JSF — фреймворк для разработки вебприложений. 
- Входит в состав платформы Java EE.
- Основан на использовании компонентов. 
- Для отображения данных используются JSP или XML-шаблоны (facelets)

+:
- (фреймворк реализует шаблон MVC). 
- Управление обменом данными на уровне компонент. 
- Простая работа с событиями на стороне сервера. 
- Расширяемость (можно использовать дополнительные наборы компонентов). 
- Широкая поддержка со стороны интегрированных средств разработки (IDE).

-:
- Высокоуровневый фреймворк — сложно реализовывать не предусмотренную авторами функциональность. 
- Сложность разработки собственных компонентов.

### 3. Angular. Приложение для регистрации и авторизации. При логине нужен email и пароль, при регистрации email, пароль и время

Сервис:

```ts
@Injectable({
  providedIn: 'root'
})
export class AuthService {
  constructor(private http: HttpClient) {}

  register(email: string, password: string, time: string) {
    // Здесь должен быть POST-запрос к вашему API для регистрации
    // Пример: return this.http.post('your_api_endpoint/register', { email, password, time });
  }

  login(email: string, password: string) {
    // Здесь должен быть POST-запрос к вашему API для логина
    // Пример: return this.http.post('your_api_endpoint/login', { email, password });
  }
}
```

Компонент регистрации:

```ts
@Component({
  selector: 'app-register',
  template: `
    <form (ngSubmit)="onSubmit()">
      <input type="email" [(ngModel)]="email" name="email" required>
      <input type="password" [(ngModel)]="password" name="password" required>
      <input type="text" [(ngModel)]="time" name="time" required>
      <button type="submit">Register</button>
    </form>
  `
})
export class RegisterComponent {
  email = '';
  password = '';
  time = '';

  constructor(private authService: AuthService) {}

  onSubmit() {
    this.authService.register(this.email, this.password, this.time)
      .subscribe(result => {
        console.log(result);
        // Обработка результатов регистрации
      });
  }
}
```

Компонент авторизации:

```ts
@Component({
  selector: 'app-login',
  template: `
    <form (ngSubmit)="onSubmit()">
      <input type="email" [(ngModel)]="email" name="email" required>
      <input type="password" [(ngModel)]="password" name="password" required>
      <button type="submit">Login</button>
    </form>
  `
})
export class LoginComponent {
  email = '';
  password = '';

  constructor(private authService: AuthService) {}

  onSubmit() {
    this.authService.login(this.email, this.password)
      .subscribe(result => {
        console.log(result);
        // Обработка результатов логина
      });
  }
}
```

## Билет 19

### 1. Rest контроллер: сериализация и десериализация

В Spring Framework REST контроллеры обычно реализуются с помощью аннотации `@RestController`, которая упрощает создание RESTful веб-сервисов. Сериализация и десериализация данных в этих контроллерах обычно управляется автоматически, что значительно упрощает процесс работы с JSON, XML и другими форматами данных.

### Сериализация и Десериализация:

1. **Сериализация (От сервера к клиенту)**:
   - Когда данные возвращаются из методов контроллера, Spring автоматически сериализует возвращаемые объекты в JSON (или другой формат, в зависимости от конфигурации) с использованием библиотеки, такой как Jackson.
   - Это происходит когда методы контроллера аннотированы `@ResponseBody` или когда контроллер аннотирован `@RestController` (который включает в себя `@Controller` + `@ResponseBody`).

2. **Десериализация (От клиента к серверу)**:
   - При получении запроса с телом (например, POST или PUT запросов), Spring автоматически десериализует входящие данные (например, JSON) в объекты Java, если это указано в параметрах метода контроллера с помощью аннотации `@RequestBody`.

Под капотом работает на библиотеке `Jackson`

### 2. Angular: архитектура. Модули, компоненты, сервисы и представления

Архитектура Angular приложения основана на модулях, компонентах, представлениях и сервисах. Эти концепции помогают организовать код, улучшить его читаемость, возможность масштабируемости и облегчить его поддержку.

1. Модуль - это класс с декоратором @NgModule(), который служит изолирующей логической объединяющей структурой для компонентов, директив, пайпов и сервисов. • Каждое приложение обязательно включает в себя корневой модуль (root module) под названием AppModule (файл app.module.ts). 
- Могут ссылаться друг на друга (т.е. возможны импорт и экспорт модулей)

2. Компонент - обособленная часть функционала со своей логикой, HTML- шаблоном и CSS-стилями. Компонент управляет отображение представление на экране. За объявление компонента отвечает декоратор @Component()
- Каждый компонент представляет собой независимую часть пользовательского интерфейса и описывает свое поведение, отображение данных и взаимодействие с пользователем. 

3. Представление (Views):
   - Представления представляют собой шаблоны, содержащие HTML и директивы Angular, которые определяют отображение компонентов в браузере.

4. Сервис - это класс, который является поставщиком данных,  обеспечивают общую функциональность. Сервисы инкапсулируют бизнес логику приложения. Сервисы могут предоставлять интерфейс взаимодействия между отдельными не связанными друг с другом компонентами. 
- Реализуются в виде отдельных классов в соответствии с принципами ООП. 
- Компонент может делегировать какие-либо из своих задач сервисам. 
- Доступ компонентов к сервисам реализуется с помощью DI


### 3. 

## Билет 20

### 1. FacesServlet - назначение и конфигурация

Класс FacesServlet
- Центральный компонент в архитектуре JSF, контроллер в шаблоне MVC
- Обрабатывает запросы с браузера.
- Формирует объекты-события и вызывает методы-слушатели.
- Управляет жизненным циклом запроса (прохождение через все фазы)
- Конфигурация задается в web.xml
- 
![image](https://github.com/eliteSufferer/ITMO_Studies/assets/46615564/3acfeeef-244a-4def-bc25-bf747f8bf3c6)


Пример конфигурации:

```xml
<!-- Faces Servlet -->
<servlet>
<servlet-name>Faces Servlet</servlet-name>
<servlet-class>javax.faces.webapp.FacesServlet</servlet-class>
<load-on-startup>1</load-on-startup>
</servlet>
<!-- Faces Servlet Mapping -->
<servlet-mapping>
<servlet-name>Faces Servlet</servlet-name>
<url-pattern>/faces/*</url-pattern>
</servlet-mapping>
```

### 2. React - особенности, плюсы и минусы использования

См. Билет 9

### 3. Написать REST-контроллер на Spring MVC, предоставляющий CRUD-интерфейс(Creat, Read, Update, Delete) к таблице со списком покемонов. Read должно получать из бд покемона по уникальному номеру, а также получать страницу с покемонами по номеру страницы.

Сущность:
```java
@Entity
public class Pokemon {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private String type;

    // Конструкторы, геттеры и сеттеры
}
```

Репозиторий:
```java
@Repository
public interface PokemonRepository extends JpaRepository<Pokemon, Long> {
}
```

Сервис:
```java
@Service
public class PokemonService {
    @Autowired
    private PokemonRepository pokemonRepository;

    public Pokemon save(Pokemon pokemon) {
        return pokemonRepository.save(pokemon);
    }

    public Pokemon findById(Long id) {
        return pokemonRepository.findById(id).orElse(null);
    }

    public Page<Pokemon> findAll(Pageable pageable) {
        return pokemonRepository.findAll(pageable);
    }

    public Pokemon update(Pokemon pokemon) {
        return pokemonRepository.save(pokemon);
    }

    public void delete(Long id) {
        pokemonRepository.deleteById(id);
    }
}
```

Контроллер:
```java
@RestController
@RequestMapping("/pokemons")
public class PokemonController {

    @Autowired
    private PokemonService pokemonService;

    @PostMapping
    public Pokemon create(@RequestBody Pokemon pokemon) {
        return pokemonService.save(pokemon);
    }

    @GetMapping("/{id}")
    public Pokemon read(@PathVariable Long id) {
        return pokemonService.findById(id);
    }

    @GetMapping
    public Page<Pokemon> readAll(Pageable pageable) {
        return pokemonService.findAll(pageable);
    }

    @PutMapping
    public Pokemon update(@RequestBody Pokemon pokemon) {
        return pokemonService.update(pokemon);
    }

    @DeleteMapping("/{id}")
    public void delete(@PathVariable Long id) {
        pokemonService.delete(id);
    }
}
```

## Билет 21

### 1. Структура JSF приложения

- JSP или XHTML-страницы, содержащие компоненты GUI.
- Библиотеки тегов.
- Управляемые бины.
- Дополнительные объекты (компоненты, конвертеры и валидаторы).
- Дополнительные теги.
- Конфигурация — faces-config.xml (опционально).
- Дескриптор развёртывания — web.xml.

### 2. Spring Web MVC: особенности, реализация, интегрирование с серверами приложений Java/Jakarta EE

Про все писали выше

**Интеграция с серверами приложений Java EE**

Интеграция Spring MVC с серверами приложений Java/Jakarta EE включает в себя несколько ключевых аспектов и общих принципов:

#### 1. Совместимость с Серверами Приложений

Spring MVC разработан так, чтобы быть совместимым со стандартными серверами приложений Java/Jakarta EE, такими как Tomcat, Jetty, WildFly, GlassFish и др. Это означает, что приложения на Spring MVC можно развертывать на этих серверах без необходимости специальной адаптации или конфигурации сервера.

#### 2. Развертывание в виде WAR-файла

- Приложения Spring MVC обычно упаковываются в WAR-файлы (Web Application Archive), которые затем развертываются на сервере приложений.
- Конфигурация контекста Spring (как XML, так и Java Config) и дескриптор развертывания веб-приложения (`web.xml`) упаковываются внутри WAR-файла.

#### 3. Встроенный и Внешний Серверы Приложений

- **Внешний Сервер**: Spring MVC может использоваться на внешних серверах приложений, где приложение развертывается как стандартный WAR.
- **Встроенный Сервер**: С появлением Spring Boot стало возможным создание самодостаточных приложений с встроенным сервером приложений (например, Tomcat или Jetty), что упрощает разработку и тестирование.

#### 4. Использование Spring Beans вместо EJB

- Вместо использования Enterprise JavaBeans (EJB) Spring предлагает управляемые бины (Spring Beans), которые работают в контейнере IoC (Inversion of Control) Spring.
- Это обеспечивает более легковесный и гибкий подход к разработке по сравнению с традиционными EJB.

#### 5. Транзакционное Управление

- Spring предоставляет свои собственные механизмы для управления транзакциями, которые могут быть интегрированы с транзакционными системами серверов приложений.
- Транзакционное управление в Spring может быть осуществлено декларативно (с помощью аннотаций) или программно.



### 3.Spring Rest контроллер реализующий калькулятор для целых чисел (4 байта, операции + - * /), должна быть реализована валидация чисел

```java
@RestController
@RequestMapping("/calculator")
@Validated
public class CalculatorController {

    @GetMapping("/add")
    public int add(@RequestParam @NotNull @Min(Integer.MIN_VALUE) @Max(Integer.MAX_VALUE) Integer a,
                   @RequestParam @NotNull @Min(Integer.MIN_VALUE) @Max(Integer.MAX_VALUE) Integer b) {
        return a + b;
    }

    @GetMapping("/subtract")
    public int subtract(@RequestParam @NotNull @Min(Integer.MIN_VALUE) @Max(Integer.MAX_VALUE) Integer a,
                        @RequestParam @NotNull @Min(Integer.MIN_VALUE) @Max(Integer.MAX_VALUE) Integer b) {
        return a - b;
    }

    @GetMapping("/multiply")
    public int multiply(@RequestParam @NotNull @Min(Integer.MIN_VALUE) @Max(Integer.MAX_VALUE) Integer a,
                        @RequestParam @NotNull @Min(Integer.MIN_VALUE) @Max(Integer.MAX_VALUE) Integer b) {
        return a * b;
    }

    @GetMapping("/divide")
    public int divide(@RequestParam @NotNull @Min(Integer.MIN_VALUE) @Max(Integer.MAX_VALUE) Integer a,
                      @RequestParam @NotNull @Min(1) @Max(Integer.MAX_VALUE) Integer b) {
        return a / b;
    }
}
```


## Билет 22

### 1. Spring бины.@Component, стереотипы

В Spring Framework, бины — это объекты, которые формируют основу вашего приложения и управляются контейнером Spring IoC (Inversion of Control). Для удобства работы с бинами в Spring были введены аннотации стереотипов. Они не только помогают в автоматическом определении бинов в контексте Spring, но и указывают на их роль в приложении. Наиболее распространенные аннотации стереотипов — это `@Component`, `@Service`, `@Repository`, и `@Controller`.

### @Component

- **Описание**: Это общая аннотация, указывающая, что класс является компонентом Spring. Классы, помеченные этой аннотацией, автоматически обнаруживаются сканированием путей классов и регистрируются в контексте Spring как бины.
- **Использование**: Используется для классов, которые не попадают под более конкретные стереотипы (`@Service`, `@Repository`, `@Controller`).

### @Service

- **Описание**: Специализированная форма `@Component`, используемая в слое сервисов. Она указывает на классы, которые выполняют бизнес-логику.
- **Использование**: Применяется к классам, которые содержат бизнес-логику. Это помогает в документировании и организации кода, а также может быть использовано для специальной обработки в рамках контейнера.

### @Repository

- **Описание**: Еще одна специализированная версия `@Component`, предназначенная для слоя доступа к данным, обычно используемого для взаимодействия с базой данных.
- **Использование**: Обозначает классы, которые осуществляют операции с базой данных, например, через JPA или Hibernate. Особенностью `@Repository` является возможность автоматической обработки исключений на уровне доступа к данным.

### @Controller

- **Описание**: Эта аннотация используется в веб-приложениях Spring MVC и обозначает классы, которые выполняют роль контроллеров в модели MVC.
- **Использование**: Применяется к классам, которые обрабатывают HTTP-запросы. Контроллеры обрабатывают входящие запросы, выполняют необходимые действия (часто с помощью сервисов) и возвращают представление.

### 2. Структура приложения React (по другой версии - Разметка в React). JSX

**Архитектура**
Архитектура приложений на React включает несколько ключевых составных частей, которые определяют структуру и способ взаимодействия различных элементов приложения:

1. **Компоненты**:
   - Основа архитектуры React — это компоненты. Каждый компонент представляет собой независимый блок кода, который отвечает за определенную часть пользовательского интерфейса (UI).
   - Компоненты могут быть функциональными или классовыми. Функциональные компоненты часто используются для простых задач и поддерживают хуки. Классовые компоненты имеют методы жизненного цикла и более подходят для сложных задач.

2. **Пропсы (Props)**:
   - Свойства (или пропсы) — это параметры, которые передаются компонентам. Они позволяют компонентам быть конфигурируемыми и переиспользуемыми.

3. **Состояние (State)**:
   - Состояние — это данные, которые компоненты могут хранить внутри себя и которые могут изменяться во время жизни компонента. Состояние важно для динамических компонентов, таких как формы или интерактивные списки.

4. **Хуки (Hooks)**:
   - Хуки — это функции, которые позволяют использовать состояние и другие возможности React без создания класса. `useState` и `useEffect` являются наиболее распространенными хуками.

5. **Контекст (Context)**:
   - Контекст позволяет передавать данные напрямую через дерево компонентов, избегая пропс-дрелинга (необходимости передавать пропсы на каждом уровне).

6. **Рефы (Refs)**:
   - Рефы предоставляют способ доступа к DOM-элементам или компонентам React напрямую.

7. **Маршрутизация (Routing)**:
   - Библиотеки маршрутизации, такие как React Router, используются для навигации между различными представлениями в одностраничных приложениях (SPA).

8. **Управление состоянием приложения**:
   - Для сложных приложений может понадобиться централизованное управление состоянием. Redux, MobX и Context API — популярные инструменты для этого.

9. **Виртуальный DOM**:
   - Виртуальный DOM — это легковесное представление реального DOM-дерева, которое позволяет React оптимизировать обновления, сначала применяя изменения к виртуальному DOM, а затем синхронизируя его с реальным DOM.


**Разметка в React**

В React разметка создается с использованием JSX (JavaScript XML) — расширения языка JavaScript. JSX позволяет писать компоненты React, используя синтаксис, похожий на HTML, но с полной мощностью JavaScript. Это упрощает процесс создания интерфейса, делая код более читаемым и лаконичным.

**Особенности JSX**

- Смешивание HTML и JavaScript: JSX позволяет смешивать HTML-теги и JavaScript-выражения. JavaScript выражения вставляются в JSX с помощью фигурных скобок {}.

- Компонентный Подход: Каждый JSX тег является объявлением React компонента. Компоненты могут быть как встроенными HTML-тегами (например, <div>, <span>), так и пользовательскими компонентами.

- Свойства (Props): Как и в HTML, в JSX можно использовать атрибуты для передачи данных и настроек в компоненты. В React эти атрибуты называются "props".

- Дети (Children): JSX поддерживает компоновку компонентов, где одни компоненты могут быть "детьми" других.

Еще где-то выше было

### 3. 

```java
@ManagedBean
@SessionScoped
public class EducationPlanManager {

    private List<EducationPlan> educationPlans;

    @PostConstruct
    public void init() {
        educationPlans = new ArrayList<>();
        loadEducationPlans();
    }

    private void loadEducationPlans() {
        try {
            InitialContext initialContext = new InitialContext();
            DataSource dataSource = (DataSource) initialContext.lookup("java:comp/env/jdbc/OrbisPool");
            
            try (Connection connection = dataSource.getConnection();
                 PreparedStatement statement = connection.prepareStatement("SELECT * FROM Н_УЧЕБНЫЕ_ПЛАНЫ");
                 ResultSet resultSet = statement.executeQuery()) {

                while (resultSet.next()) {
                    EducationPlan plan = new EducationPlan();
                    // Здесь должно быть заполнение объекта plan данными из resultSet
                    educationPlans.add(plan);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            // Обработка исключений
        }
    }

    public List<EducationPlan> getEducationPlans() {
        return educationPlans;
    }

    // Дополнительные методы и класс EducationPlan
}
```

Использование:
```html
<h:dataTable value="#{educationPlanManager.educationPlans}" var="plan">
    <h:column>
        <f:facet name="header">Название колонки</f:facet>
        #{plan.propertyName}
    </h:column>
</h:dataTable>
```

## Билет 23

### 1. Фаза получения значений компонентов (Apply Request Values Phase)

После фазы формирования представления и перед фазой валидации.

- На стороне клиента все значения хранятся в строковом формате — нужна проверка их корректности:
- Вызывается конвертер в соответствии с типом данных значения.
- Если конвертация заканчивается успешно, значение сохраняется в локальной переменной компонента.
- Если конвертация заканчивается неудачно, создаётся сообщение об ошибке, которое помещается в FacesContext.

### 2. Реализация IoC и CDI в Spring

**В общих чертах**

Объекты не создаются и не управляются напрямую программистом, а передаются контейнеру (например, в Spring ApplicationContext), для управления их ЖЦ.
DI: внедрять зависимости можно через конструктор, поле или сеттер, пометив их @Autowired.

**Про DI**
В Spring Framework внедрение зависимостей (Dependency Injection, DI) — это ключевая концепция, которая используется для создания слабо связанных приложений. DI в Spring позволяет инжектировать объекты (зависимости) в классы, не создавая их явно в коде. Вместо этого, Spring контейнер заботится об этом, используя конфигурацию, заданную либо в XML, либо с помощью аннотаций, либо через Java-конфигурацию.

Вот как это работает:

1. **Контейнер IoC (Inversion of Control)**: В основе Spring DI лежит IoC контейнер, который управляет созданием и жизненным циклом бинов (объектов), зарегистрированных в контейнере.

2. **Аннотации для DI**:
   - `@Autowired`: Автоматически инжектирует бин по типу. Может использоваться на полях, сеттерах и конструкторах.
   - `@Qualifier`: Указывает, какой именно бин следует инжектировать, когда имеется несколько кандидатов одного и того же типа.
   - `@Resource`: Похож на `@Autowired`, но инжекция происходит по имени бина.
   - `@Inject`: Стандарт JSR-330 для инъекции зависимостей, похож на `@Autowired`.

3. **Конструктор, Сеттеры, и Поля для Инъекции**:
   - **Инъекция через конструктор**: Преимущества в том, что объект создается сразу со всеми необходимыми зависимостями, идеально подходит для обязательных зависимостей.
   - **Инъекция через сеттеры**: Используется для необязательных зависимостей.
   - **Инъекция в поля**: Хотя это удобно, не рекомендуется из-за того, что оно нарушает инкапсуляцию и затрудняет тестирование.

4. **XML-конфигурация**:
   - Ранее Spring использовал XML файлы для конфигурации бинов, но этот подход становится все менее популярным в пользу аннотаций и Java-конфигурации.

5. **Java-конфигурация**:
   - `@Configuration`: Классы с этой аннотацией определяют бины контейнера Spring.
   - `@Bean`: Методы с этой аннотацией возвращают объекты, которые автоматически регистрируются как бины в Spring контейнере.

6. **Profiles**:
   - `@Profile`: Определяет, при каких условиях бин должен быть активирован.

7. **Scope**:
   - `@Scope`: Определяет область видимости бина, такую как singleton (по умолчанию), prototype и другие.


**Про IoC**

Inversion of Control (IoC) в Spring Framework реализуется через IoC контейнер. Контейнер управляет созданием объектов, их жизненным циклом и конфигурацией зависимостей. В Spring IoC контейнер достигается через два основных интерфейса: `BeanFactory` и более расширенный `ApplicationContext`.

### Реализация IoC в Spring:

1. **Конфигурация**:
   - В Spring IoC можно настроить с помощью XML, аннотаций или Java-конфигурации. Разработчики могут выбрать один из этих подходов или комбинацию в зависимости от требований проекта.

2. **Bean Definitions**:
   - В конфигурации бинов определяются метаданные, которые IoC контейнер использует для создания и управления бинами и их зависимостями.

3. **Bean Scopes**:
   - Spring поддерживает различные области видимости для бинов, например, singleton (один экземпляр на контейнер), prototype (новый экземпляр для каждого запроса) и другие.

4. **Bean Lifecycle**:
   - Spring управляет полным жизненным циклом бинов, от создания до уничтожения. Разработчики могут вмешаться в этот процесс, используя аннотации или интерфейсы, такие как `InitializingBean`, `DisposableBean`, или кастомные методы с аннотациями `@PostConstruct` и `@PreDestroy`.

5. **Dependency Resolution**:
   - Зависимости между бинами разрешаются контейнером IoC либо автоматически (автопроводка), либо конфигурационно, в зависимости от того, какие бины требуются другим бинам для их работы.

6. **Event Handling**:
   - Spring IoC контейнер также предоставляет поддержку событий и слушателей, что позволяет бинам реагировать на события внутри приложения.

### 3. Написать на React интерфейс интернет-магазина "НВидио", показывающий список товаров с возможностью сортировать их по категории

#### Компонент `Product`

Этот компонент отображает информацию о товаре.

```jsx
function Product({ product }) {
  return (
    <div className="product">
      <h3>{product.name}</h3>
      <p>{product.description}</p>
      {/* Дополнительная информация о продукте */}
    </div>
  );
}
```

#### Компонент `ProductList`

Этот компонент отображает список товаров.

```jsx
function ProductList({ products }) {
  return (
    <div>
      {products.map(product => (
        <Product key={product.id} product={product} />
      ))}
    </div>
  );
}
```

#### Компонент `CategoryFilter`

Этот компонент позволяет фильтровать товары по категории.

```jsx
function CategoryFilter({ categories, onCategoryChange }) {
  return (
    <select onChange={(e) => onCategoryChange(e.target.value)}>
      <option value="">Все категории</option>
      {categories.map(category => (
        <option key={category} value={category}>{category}</option>
      ))}
    </select>
  );
}
```

### 3. Состояние и Логика в Главном Компоненте

Ваш главный компонент (`App`) будет управлять состоянием приложения.

```jsx
import React, { useState, useEffect } from 'react';
import ProductList from './ProductList';
import CategoryFilter from './CategoryFilter';

function App() {
  const [products, setProducts] = useState([]);
  const [filteredProducts, setFilteredProducts] = useState([]);
  const [categories, setCategories] = useState([]);

  useEffect(() => {
    // Здесь должен быть код для получения данных о товарах
    // setProducts(полученные_товары);
    // setCategories(извлечь_уникальные_категории_из_товаров);
  }, []);

  const handleCategoryChange = category => {
    if (category) {
      setFilteredProducts(products.filter(p => p.category === category));
    } else {
      setFilteredProducts(products);
    }
  };

  return (
    <div>
      <CategoryFilter categories={categories} onCategoryChange={handleCategoryChange} />
      <ProductList products={filteredProducts.length > 0 ? filteredProducts : products} />
    </div>
  );
}

export default App;
```

